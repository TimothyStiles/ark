// Code generated by SQLBoiler 4.11.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Assay is an object representing the database table.
type Assay struct {
	AssayID                  int64       `boil:"assay_id" json:"assay_id" toml:"assay_id" yaml:"assay_id"`
	DocID                    int64       `boil:"doc_id" json:"doc_id" toml:"doc_id" yaml:"doc_id"`
	Description              null.String `boil:"description" json:"description,omitempty" toml:"description" yaml:"description,omitempty"`
	AssayType                null.String `boil:"assay_type" json:"assay_type,omitempty" toml:"assay_type" yaml:"assay_type,omitempty"`
	AssayTestType            null.String `boil:"assay_test_type" json:"assay_test_type,omitempty" toml:"assay_test_type" yaml:"assay_test_type,omitempty"`
	AssayCategory            null.String `boil:"assay_category" json:"assay_category,omitempty" toml:"assay_category" yaml:"assay_category,omitempty"`
	AssayOrganism            null.String `boil:"assay_organism" json:"assay_organism,omitempty" toml:"assay_organism" yaml:"assay_organism,omitempty"`
	AssayTaxID               null.Int64  `boil:"assay_tax_id" json:"assay_tax_id,omitempty" toml:"assay_tax_id" yaml:"assay_tax_id,omitempty"`
	AssayStrain              null.String `boil:"assay_strain" json:"assay_strain,omitempty" toml:"assay_strain" yaml:"assay_strain,omitempty"`
	AssayTissue              null.String `boil:"assay_tissue" json:"assay_tissue,omitempty" toml:"assay_tissue" yaml:"assay_tissue,omitempty"`
	AssayCellType            null.String `boil:"assay_cell_type" json:"assay_cell_type,omitempty" toml:"assay_cell_type" yaml:"assay_cell_type,omitempty"`
	AssaySubcellularFraction null.String `boil:"assay_subcellular_fraction" json:"assay_subcellular_fraction,omitempty" toml:"assay_subcellular_fraction" yaml:"assay_subcellular_fraction,omitempty"`
	Tid                      null.Int64  `boil:"tid" json:"tid,omitempty" toml:"tid" yaml:"tid,omitempty"`
	RelationshipType         null.String `boil:"relationship_type" json:"relationship_type,omitempty" toml:"relationship_type" yaml:"relationship_type,omitempty"`
	ConfidenceScore          null.Int16  `boil:"confidence_score" json:"confidence_score,omitempty" toml:"confidence_score" yaml:"confidence_score,omitempty"`
	CuratedBy                null.String `boil:"curated_by" json:"curated_by,omitempty" toml:"curated_by" yaml:"curated_by,omitempty"`
	SRCID                    int64       `boil:"src_id" json:"src_id" toml:"src_id" yaml:"src_id"`
	SRCAssayID               null.String `boil:"src_assay_id" json:"src_assay_id,omitempty" toml:"src_assay_id" yaml:"src_assay_id,omitempty"`
	ChemblID                 string      `boil:"chembl_id" json:"chembl_id" toml:"chembl_id" yaml:"chembl_id"`
	CellID                   null.Int64  `boil:"cell_id" json:"cell_id,omitempty" toml:"cell_id" yaml:"cell_id,omitempty"`
	BaoFormat                null.String `boil:"bao_format" json:"bao_format,omitempty" toml:"bao_format" yaml:"bao_format,omitempty"`
	TissueID                 null.Int64  `boil:"tissue_id" json:"tissue_id,omitempty" toml:"tissue_id" yaml:"tissue_id,omitempty"`
	VariantID                null.Int64  `boil:"variant_id" json:"variant_id,omitempty" toml:"variant_id" yaml:"variant_id,omitempty"`
	Aidx                     string      `boil:"aidx" json:"aidx" toml:"aidx" yaml:"aidx"`

	R *assayR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L assayL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var AssayColumns = struct {
	AssayID                  string
	DocID                    string
	Description              string
	AssayType                string
	AssayTestType            string
	AssayCategory            string
	AssayOrganism            string
	AssayTaxID               string
	AssayStrain              string
	AssayTissue              string
	AssayCellType            string
	AssaySubcellularFraction string
	Tid                      string
	RelationshipType         string
	ConfidenceScore          string
	CuratedBy                string
	SRCID                    string
	SRCAssayID               string
	ChemblID                 string
	CellID                   string
	BaoFormat                string
	TissueID                 string
	VariantID                string
	Aidx                     string
}{
	AssayID:                  "assay_id",
	DocID:                    "doc_id",
	Description:              "description",
	AssayType:                "assay_type",
	AssayTestType:            "assay_test_type",
	AssayCategory:            "assay_category",
	AssayOrganism:            "assay_organism",
	AssayTaxID:               "assay_tax_id",
	AssayStrain:              "assay_strain",
	AssayTissue:              "assay_tissue",
	AssayCellType:            "assay_cell_type",
	AssaySubcellularFraction: "assay_subcellular_fraction",
	Tid:                      "tid",
	RelationshipType:         "relationship_type",
	ConfidenceScore:          "confidence_score",
	CuratedBy:                "curated_by",
	SRCID:                    "src_id",
	SRCAssayID:               "src_assay_id",
	ChemblID:                 "chembl_id",
	CellID:                   "cell_id",
	BaoFormat:                "bao_format",
	TissueID:                 "tissue_id",
	VariantID:                "variant_id",
	Aidx:                     "aidx",
}

var AssayTableColumns = struct {
	AssayID                  string
	DocID                    string
	Description              string
	AssayType                string
	AssayTestType            string
	AssayCategory            string
	AssayOrganism            string
	AssayTaxID               string
	AssayStrain              string
	AssayTissue              string
	AssayCellType            string
	AssaySubcellularFraction string
	Tid                      string
	RelationshipType         string
	ConfidenceScore          string
	CuratedBy                string
	SRCID                    string
	SRCAssayID               string
	ChemblID                 string
	CellID                   string
	BaoFormat                string
	TissueID                 string
	VariantID                string
	Aidx                     string
}{
	AssayID:                  "assays.assay_id",
	DocID:                    "assays.doc_id",
	Description:              "assays.description",
	AssayType:                "assays.assay_type",
	AssayTestType:            "assays.assay_test_type",
	AssayCategory:            "assays.assay_category",
	AssayOrganism:            "assays.assay_organism",
	AssayTaxID:               "assays.assay_tax_id",
	AssayStrain:              "assays.assay_strain",
	AssayTissue:              "assays.assay_tissue",
	AssayCellType:            "assays.assay_cell_type",
	AssaySubcellularFraction: "assays.assay_subcellular_fraction",
	Tid:                      "assays.tid",
	RelationshipType:         "assays.relationship_type",
	ConfidenceScore:          "assays.confidence_score",
	CuratedBy:                "assays.curated_by",
	SRCID:                    "assays.src_id",
	SRCAssayID:               "assays.src_assay_id",
	ChemblID:                 "assays.chembl_id",
	CellID:                   "assays.cell_id",
	BaoFormat:                "assays.bao_format",
	TissueID:                 "assays.tissue_id",
	VariantID:                "assays.variant_id",
	Aidx:                     "assays.aidx",
}

// Generated where

var AssayWhere = struct {
	AssayID                  whereHelperint64
	DocID                    whereHelperint64
	Description              whereHelpernull_String
	AssayType                whereHelpernull_String
	AssayTestType            whereHelpernull_String
	AssayCategory            whereHelpernull_String
	AssayOrganism            whereHelpernull_String
	AssayTaxID               whereHelpernull_Int64
	AssayStrain              whereHelpernull_String
	AssayTissue              whereHelpernull_String
	AssayCellType            whereHelpernull_String
	AssaySubcellularFraction whereHelpernull_String
	Tid                      whereHelpernull_Int64
	RelationshipType         whereHelpernull_String
	ConfidenceScore          whereHelpernull_Int16
	CuratedBy                whereHelpernull_String
	SRCID                    whereHelperint64
	SRCAssayID               whereHelpernull_String
	ChemblID                 whereHelperstring
	CellID                   whereHelpernull_Int64
	BaoFormat                whereHelpernull_String
	TissueID                 whereHelpernull_Int64
	VariantID                whereHelpernull_Int64
	Aidx                     whereHelperstring
}{
	AssayID:                  whereHelperint64{field: "\"assays\".\"assay_id\""},
	DocID:                    whereHelperint64{field: "\"assays\".\"doc_id\""},
	Description:              whereHelpernull_String{field: "\"assays\".\"description\""},
	AssayType:                whereHelpernull_String{field: "\"assays\".\"assay_type\""},
	AssayTestType:            whereHelpernull_String{field: "\"assays\".\"assay_test_type\""},
	AssayCategory:            whereHelpernull_String{field: "\"assays\".\"assay_category\""},
	AssayOrganism:            whereHelpernull_String{field: "\"assays\".\"assay_organism\""},
	AssayTaxID:               whereHelpernull_Int64{field: "\"assays\".\"assay_tax_id\""},
	AssayStrain:              whereHelpernull_String{field: "\"assays\".\"assay_strain\""},
	AssayTissue:              whereHelpernull_String{field: "\"assays\".\"assay_tissue\""},
	AssayCellType:            whereHelpernull_String{field: "\"assays\".\"assay_cell_type\""},
	AssaySubcellularFraction: whereHelpernull_String{field: "\"assays\".\"assay_subcellular_fraction\""},
	Tid:                      whereHelpernull_Int64{field: "\"assays\".\"tid\""},
	RelationshipType:         whereHelpernull_String{field: "\"assays\".\"relationship_type\""},
	ConfidenceScore:          whereHelpernull_Int16{field: "\"assays\".\"confidence_score\""},
	CuratedBy:                whereHelpernull_String{field: "\"assays\".\"curated_by\""},
	SRCID:                    whereHelperint64{field: "\"assays\".\"src_id\""},
	SRCAssayID:               whereHelpernull_String{field: "\"assays\".\"src_assay_id\""},
	ChemblID:                 whereHelperstring{field: "\"assays\".\"chembl_id\""},
	CellID:                   whereHelpernull_Int64{field: "\"assays\".\"cell_id\""},
	BaoFormat:                whereHelpernull_String{field: "\"assays\".\"bao_format\""},
	TissueID:                 whereHelpernull_Int64{field: "\"assays\".\"tissue_id\""},
	VariantID:                whereHelpernull_Int64{field: "\"assays\".\"variant_id\""},
	Aidx:                     whereHelperstring{field: "\"assays\".\"aidx\""},
}

// AssayRels is where relationship names are stored.
var AssayRels = struct {
	BaoFormatBioassayOntology            string
	Variant                              string
	Tissue                               string
	TidTargetDictionary                  string
	SRC                                  string
	AssayRelationshipType                string
	Doc                                  string
	CuratedByCurationLookup              string
	ConfidenceScoreConfidenceScoreLookup string
	Chembl                               string
	Cell                                 string
	AssayAssayType                       string
	Activities                           string
	AssayClassMaps                       string
	AssayParameters                      string
}{
	BaoFormatBioassayOntology:            "BaoFormatBioassayOntology",
	Variant:                              "Variant",
	Tissue:                               "Tissue",
	TidTargetDictionary:                  "TidTargetDictionary",
	SRC:                                  "SRC",
	AssayRelationshipType:                "AssayRelationshipType",
	Doc:                                  "Doc",
	CuratedByCurationLookup:              "CuratedByCurationLookup",
	ConfidenceScoreConfidenceScoreLookup: "ConfidenceScoreConfidenceScoreLookup",
	Chembl:                               "Chembl",
	Cell:                                 "Cell",
	AssayAssayType:                       "AssayAssayType",
	Activities:                           "Activities",
	AssayClassMaps:                       "AssayClassMaps",
	AssayParameters:                      "AssayParameters",
}

// assayR is where relationships are stored.
type assayR struct {
	BaoFormatBioassayOntology            *BioassayOntology      `boil:"BaoFormatBioassayOntology" json:"BaoFormatBioassayOntology" toml:"BaoFormatBioassayOntology" yaml:"BaoFormatBioassayOntology"`
	Variant                              *VariantSequence       `boil:"Variant" json:"Variant" toml:"Variant" yaml:"Variant"`
	Tissue                               *TissueDictionary      `boil:"Tissue" json:"Tissue" toml:"Tissue" yaml:"Tissue"`
	TidTargetDictionary                  *TargetDictionary      `boil:"TidTargetDictionary" json:"TidTargetDictionary" toml:"TidTargetDictionary" yaml:"TidTargetDictionary"`
	SRC                                  *Source                `boil:"SRC" json:"SRC" toml:"SRC" yaml:"SRC"`
	AssayRelationshipType                *RelationshipType      `boil:"AssayRelationshipType" json:"AssayRelationshipType" toml:"AssayRelationshipType" yaml:"AssayRelationshipType"`
	Doc                                  *Doc                   `boil:"Doc" json:"Doc" toml:"Doc" yaml:"Doc"`
	CuratedByCurationLookup              *CurationLookup        `boil:"CuratedByCurationLookup" json:"CuratedByCurationLookup" toml:"CuratedByCurationLookup" yaml:"CuratedByCurationLookup"`
	ConfidenceScoreConfidenceScoreLookup *ConfidenceScoreLookup `boil:"ConfidenceScoreConfidenceScoreLookup" json:"ConfidenceScoreConfidenceScoreLookup" toml:"ConfidenceScoreConfidenceScoreLookup" yaml:"ConfidenceScoreConfidenceScoreLookup"`
	Chembl                               *ChemblIDLookup        `boil:"Chembl" json:"Chembl" toml:"Chembl" yaml:"Chembl"`
	Cell                                 *CellDictionary        `boil:"Cell" json:"Cell" toml:"Cell" yaml:"Cell"`
	AssayAssayType                       *AssayType             `boil:"AssayAssayType" json:"AssayAssayType" toml:"AssayAssayType" yaml:"AssayAssayType"`
	Activities                           ActivitySlice          `boil:"Activities" json:"Activities" toml:"Activities" yaml:"Activities"`
	AssayClassMaps                       AssayClassMapSlice     `boil:"AssayClassMaps" json:"AssayClassMaps" toml:"AssayClassMaps" yaml:"AssayClassMaps"`
	AssayParameters                      AssayParameterSlice    `boil:"AssayParameters" json:"AssayParameters" toml:"AssayParameters" yaml:"AssayParameters"`
}

// NewStruct creates a new relationship struct
func (*assayR) NewStruct() *assayR {
	return &assayR{}
}

func (r *assayR) GetBaoFormatBioassayOntology() *BioassayOntology {
	if r == nil {
		return nil
	}
	return r.BaoFormatBioassayOntology
}

func (r *assayR) GetVariant() *VariantSequence {
	if r == nil {
		return nil
	}
	return r.Variant
}

func (r *assayR) GetTissue() *TissueDictionary {
	if r == nil {
		return nil
	}
	return r.Tissue
}

func (r *assayR) GetTidTargetDictionary() *TargetDictionary {
	if r == nil {
		return nil
	}
	return r.TidTargetDictionary
}

func (r *assayR) GetSRC() *Source {
	if r == nil {
		return nil
	}
	return r.SRC
}

func (r *assayR) GetAssayRelationshipType() *RelationshipType {
	if r == nil {
		return nil
	}
	return r.AssayRelationshipType
}

func (r *assayR) GetDoc() *Doc {
	if r == nil {
		return nil
	}
	return r.Doc
}

func (r *assayR) GetCuratedByCurationLookup() *CurationLookup {
	if r == nil {
		return nil
	}
	return r.CuratedByCurationLookup
}

func (r *assayR) GetConfidenceScoreConfidenceScoreLookup() *ConfidenceScoreLookup {
	if r == nil {
		return nil
	}
	return r.ConfidenceScoreConfidenceScoreLookup
}

func (r *assayR) GetChembl() *ChemblIDLookup {
	if r == nil {
		return nil
	}
	return r.Chembl
}

func (r *assayR) GetCell() *CellDictionary {
	if r == nil {
		return nil
	}
	return r.Cell
}

func (r *assayR) GetAssayAssayType() *AssayType {
	if r == nil {
		return nil
	}
	return r.AssayAssayType
}

func (r *assayR) GetActivities() ActivitySlice {
	if r == nil {
		return nil
	}
	return r.Activities
}

func (r *assayR) GetAssayClassMaps() AssayClassMapSlice {
	if r == nil {
		return nil
	}
	return r.AssayClassMaps
}

func (r *assayR) GetAssayParameters() AssayParameterSlice {
	if r == nil {
		return nil
	}
	return r.AssayParameters
}

// assayL is where Load methods for each relationship are stored.
type assayL struct{}

var (
	assayAllColumns            = []string{"assay_id", "doc_id", "description", "assay_type", "assay_test_type", "assay_category", "assay_organism", "assay_tax_id", "assay_strain", "assay_tissue", "assay_cell_type", "assay_subcellular_fraction", "tid", "relationship_type", "confidence_score", "curated_by", "src_id", "src_assay_id", "chembl_id", "cell_id", "bao_format", "tissue_id", "variant_id", "aidx"}
	assayColumnsWithoutDefault = []string{"assay_id", "doc_id", "src_id", "chembl_id", "aidx"}
	assayColumnsWithDefault    = []string{"description", "assay_type", "assay_test_type", "assay_category", "assay_organism", "assay_tax_id", "assay_strain", "assay_tissue", "assay_cell_type", "assay_subcellular_fraction", "tid", "relationship_type", "confidence_score", "curated_by", "src_assay_id", "cell_id", "bao_format", "tissue_id", "variant_id"}
	assayPrimaryKeyColumns     = []string{"assay_id"}
	assayGeneratedColumns      = []string{}
)

type (
	// AssaySlice is an alias for a slice of pointers to Assay.
	// This should almost always be used instead of []Assay.
	AssaySlice []*Assay
	// AssayHook is the signature for custom Assay hook methods
	AssayHook func(context.Context, boil.ContextExecutor, *Assay) error

	assayQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	assayType                 = reflect.TypeOf(&Assay{})
	assayMapping              = queries.MakeStructMapping(assayType)
	assayPrimaryKeyMapping, _ = queries.BindMapping(assayType, assayMapping, assayPrimaryKeyColumns)
	assayInsertCacheMut       sync.RWMutex
	assayInsertCache          = make(map[string]insertCache)
	assayUpdateCacheMut       sync.RWMutex
	assayUpdateCache          = make(map[string]updateCache)
	assayUpsertCacheMut       sync.RWMutex
	assayUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var assayAfterSelectHooks []AssayHook

var assayBeforeInsertHooks []AssayHook
var assayAfterInsertHooks []AssayHook

var assayBeforeUpdateHooks []AssayHook
var assayAfterUpdateHooks []AssayHook

var assayBeforeDeleteHooks []AssayHook
var assayAfterDeleteHooks []AssayHook

var assayBeforeUpsertHooks []AssayHook
var assayAfterUpsertHooks []AssayHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Assay) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assayAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Assay) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assayBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Assay) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assayAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Assay) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assayBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Assay) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assayAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Assay) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assayBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Assay) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assayAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Assay) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assayBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Assay) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range assayAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddAssayHook registers your hook function for all future operations.
func AddAssayHook(hookPoint boil.HookPoint, assayHook AssayHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		assayAfterSelectHooks = append(assayAfterSelectHooks, assayHook)
	case boil.BeforeInsertHook:
		assayBeforeInsertHooks = append(assayBeforeInsertHooks, assayHook)
	case boil.AfterInsertHook:
		assayAfterInsertHooks = append(assayAfterInsertHooks, assayHook)
	case boil.BeforeUpdateHook:
		assayBeforeUpdateHooks = append(assayBeforeUpdateHooks, assayHook)
	case boil.AfterUpdateHook:
		assayAfterUpdateHooks = append(assayAfterUpdateHooks, assayHook)
	case boil.BeforeDeleteHook:
		assayBeforeDeleteHooks = append(assayBeforeDeleteHooks, assayHook)
	case boil.AfterDeleteHook:
		assayAfterDeleteHooks = append(assayAfterDeleteHooks, assayHook)
	case boil.BeforeUpsertHook:
		assayBeforeUpsertHooks = append(assayBeforeUpsertHooks, assayHook)
	case boil.AfterUpsertHook:
		assayAfterUpsertHooks = append(assayAfterUpsertHooks, assayHook)
	}
}

// One returns a single assay record from the query.
func (q assayQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Assay, error) {
	o := &Assay{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for assays")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Assay records from the query.
func (q assayQuery) All(ctx context.Context, exec boil.ContextExecutor) (AssaySlice, error) {
	var o []*Assay

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Assay slice")
	}

	if len(assayAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Assay records in the query.
func (q assayQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count assays rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q assayQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if assays exists")
	}

	return count > 0, nil
}

// BaoFormatBioassayOntology pointed to by the foreign key.
func (o *Assay) BaoFormatBioassayOntology(mods ...qm.QueryMod) bioassayOntologyQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"bao_id\" = ?", o.BaoFormat),
	}

	queryMods = append(queryMods, mods...)

	return BioassayOntologies(queryMods...)
}

// Variant pointed to by the foreign key.
func (o *Assay) Variant(mods ...qm.QueryMod) variantSequenceQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"variant_id\" = ?", o.VariantID),
	}

	queryMods = append(queryMods, mods...)

	return VariantSequences(queryMods...)
}

// Tissue pointed to by the foreign key.
func (o *Assay) Tissue(mods ...qm.QueryMod) tissueDictionaryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"tissue_id\" = ?", o.TissueID),
	}

	queryMods = append(queryMods, mods...)

	return TissueDictionaries(queryMods...)
}

// TidTargetDictionary pointed to by the foreign key.
func (o *Assay) TidTargetDictionary(mods ...qm.QueryMod) targetDictionaryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"tid\" = ?", o.Tid),
	}

	queryMods = append(queryMods, mods...)

	return TargetDictionaries(queryMods...)
}

// SRC pointed to by the foreign key.
func (o *Assay) SRC(mods ...qm.QueryMod) sourceQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"src_id\" = ?", o.SRCID),
	}

	queryMods = append(queryMods, mods...)

	return Sources(queryMods...)
}

// AssayRelationshipType pointed to by the foreign key.
func (o *Assay) AssayRelationshipType(mods ...qm.QueryMod) relationshipTypeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"relationship_type\" = ?", o.RelationshipType),
	}

	queryMods = append(queryMods, mods...)

	return RelationshipTypes(queryMods...)
}

// Doc pointed to by the foreign key.
func (o *Assay) Doc(mods ...qm.QueryMod) docQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"doc_id\" = ?", o.DocID),
	}

	queryMods = append(queryMods, mods...)

	return Docs(queryMods...)
}

// CuratedByCurationLookup pointed to by the foreign key.
func (o *Assay) CuratedByCurationLookup(mods ...qm.QueryMod) curationLookupQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"curated_by\" = ?", o.CuratedBy),
	}

	queryMods = append(queryMods, mods...)

	return CurationLookups(queryMods...)
}

// ConfidenceScoreConfidenceScoreLookup pointed to by the foreign key.
func (o *Assay) ConfidenceScoreConfidenceScoreLookup(mods ...qm.QueryMod) confidenceScoreLookupQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"confidence_score\" = ?", o.ConfidenceScore),
	}

	queryMods = append(queryMods, mods...)

	return ConfidenceScoreLookups(queryMods...)
}

// Chembl pointed to by the foreign key.
func (o *Assay) Chembl(mods ...qm.QueryMod) chemblIDLookupQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"chembl_id\" = ?", o.ChemblID),
	}

	queryMods = append(queryMods, mods...)

	return ChemblIDLookups(queryMods...)
}

// Cell pointed to by the foreign key.
func (o *Assay) Cell(mods ...qm.QueryMod) cellDictionaryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"cell_id\" = ?", o.CellID),
	}

	queryMods = append(queryMods, mods...)

	return CellDictionaries(queryMods...)
}

// AssayAssayType pointed to by the foreign key.
func (o *Assay) AssayAssayType(mods ...qm.QueryMod) assayTypeQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"assay_type\" = ?", o.AssayType),
	}

	queryMods = append(queryMods, mods...)

	return AssayTypes(queryMods...)
}

// Activities retrieves all the activity's Activities with an executor.
func (o *Assay) Activities(mods ...qm.QueryMod) activityQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"activities\".\"assay_id\"=?", o.AssayID),
	)

	return Activities(queryMods...)
}

// AssayClassMaps retrieves all the assay_class_map's AssayClassMaps with an executor.
func (o *Assay) AssayClassMaps(mods ...qm.QueryMod) assayClassMapQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"assay_class_map\".\"assay_id\"=?", o.AssayID),
	)

	return AssayClassMaps(queryMods...)
}

// AssayParameters retrieves all the assay_parameter's AssayParameters with an executor.
func (o *Assay) AssayParameters(mods ...qm.QueryMod) assayParameterQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"assay_parameters\".\"assay_id\"=?", o.AssayID),
	)

	return AssayParameters(queryMods...)
}

// LoadBaoFormatBioassayOntology allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (assayL) LoadBaoFormatBioassayOntology(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAssay interface{}, mods queries.Applicator) error {
	var slice []*Assay
	var object *Assay

	if singular {
		object = maybeAssay.(*Assay)
	} else {
		slice = *maybeAssay.(*[]*Assay)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &assayR{}
		}
		if !queries.IsNil(object.BaoFormat) {
			args = append(args, object.BaoFormat)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &assayR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BaoFormat) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BaoFormat) {
				args = append(args, obj.BaoFormat)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`bioassay_ontology`),
		qm.WhereIn(`bioassay_ontology.bao_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load BioassayOntology")
	}

	var resultSlice []*BioassayOntology
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice BioassayOntology")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for bioassay_ontology")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for bioassay_ontology")
	}

	if len(assayAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BaoFormatBioassayOntology = foreign
		if foreign.R == nil {
			foreign.R = &bioassayOntologyR{}
		}
		foreign.R.BaoFormatAssays = append(foreign.R.BaoFormatAssays, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BaoFormat, foreign.BaoID) {
				local.R.BaoFormatBioassayOntology = foreign
				if foreign.R == nil {
					foreign.R = &bioassayOntologyR{}
				}
				foreign.R.BaoFormatAssays = append(foreign.R.BaoFormatAssays, local)
				break
			}
		}
	}

	return nil
}

// LoadVariant allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (assayL) LoadVariant(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAssay interface{}, mods queries.Applicator) error {
	var slice []*Assay
	var object *Assay

	if singular {
		object = maybeAssay.(*Assay)
	} else {
		slice = *maybeAssay.(*[]*Assay)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &assayR{}
		}
		if !queries.IsNil(object.VariantID) {
			args = append(args, object.VariantID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &assayR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.VariantID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.VariantID) {
				args = append(args, obj.VariantID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`variant_sequences`),
		qm.WhereIn(`variant_sequences.variant_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load VariantSequence")
	}

	var resultSlice []*VariantSequence
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice VariantSequence")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for variant_sequences")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for variant_sequences")
	}

	if len(assayAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Variant = foreign
		if foreign.R == nil {
			foreign.R = &variantSequenceR{}
		}
		foreign.R.VariantAssays = append(foreign.R.VariantAssays, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.VariantID, foreign.VariantID) {
				local.R.Variant = foreign
				if foreign.R == nil {
					foreign.R = &variantSequenceR{}
				}
				foreign.R.VariantAssays = append(foreign.R.VariantAssays, local)
				break
			}
		}
	}

	return nil
}

// LoadTissue allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (assayL) LoadTissue(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAssay interface{}, mods queries.Applicator) error {
	var slice []*Assay
	var object *Assay

	if singular {
		object = maybeAssay.(*Assay)
	} else {
		slice = *maybeAssay.(*[]*Assay)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &assayR{}
		}
		if !queries.IsNil(object.TissueID) {
			args = append(args, object.TissueID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &assayR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.TissueID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.TissueID) {
				args = append(args, obj.TissueID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`tissue_dictionary`),
		qm.WhereIn(`tissue_dictionary.tissue_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TissueDictionary")
	}

	var resultSlice []*TissueDictionary
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TissueDictionary")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for tissue_dictionary")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for tissue_dictionary")
	}

	if len(assayAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Tissue = foreign
		if foreign.R == nil {
			foreign.R = &tissueDictionaryR{}
		}
		foreign.R.TissueAssays = append(foreign.R.TissueAssays, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.TissueID, foreign.TissueID) {
				local.R.Tissue = foreign
				if foreign.R == nil {
					foreign.R = &tissueDictionaryR{}
				}
				foreign.R.TissueAssays = append(foreign.R.TissueAssays, local)
				break
			}
		}
	}

	return nil
}

// LoadTidTargetDictionary allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (assayL) LoadTidTargetDictionary(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAssay interface{}, mods queries.Applicator) error {
	var slice []*Assay
	var object *Assay

	if singular {
		object = maybeAssay.(*Assay)
	} else {
		slice = *maybeAssay.(*[]*Assay)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &assayR{}
		}
		if !queries.IsNil(object.Tid) {
			args = append(args, object.Tid)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &assayR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Tid) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Tid) {
				args = append(args, obj.Tid)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`target_dictionary`),
		qm.WhereIn(`target_dictionary.tid in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load TargetDictionary")
	}

	var resultSlice []*TargetDictionary
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice TargetDictionary")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for target_dictionary")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for target_dictionary")
	}

	if len(assayAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.TidTargetDictionary = foreign
		if foreign.R == nil {
			foreign.R = &targetDictionaryR{}
		}
		foreign.R.TidAssays = append(foreign.R.TidAssays, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Tid, foreign.Tid) {
				local.R.TidTargetDictionary = foreign
				if foreign.R == nil {
					foreign.R = &targetDictionaryR{}
				}
				foreign.R.TidAssays = append(foreign.R.TidAssays, local)
				break
			}
		}
	}

	return nil
}

// LoadSRC allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (assayL) LoadSRC(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAssay interface{}, mods queries.Applicator) error {
	var slice []*Assay
	var object *Assay

	if singular {
		object = maybeAssay.(*Assay)
	} else {
		slice = *maybeAssay.(*[]*Assay)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &assayR{}
		}
		args = append(args, object.SRCID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &assayR{}
			}

			for _, a := range args {
				if a == obj.SRCID {
					continue Outer
				}
			}

			args = append(args, obj.SRCID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`source`),
		qm.WhereIn(`source.src_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Source")
	}

	var resultSlice []*Source
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Source")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for source")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for source")
	}

	if len(assayAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SRC = foreign
		if foreign.R == nil {
			foreign.R = &sourceR{}
		}
		foreign.R.SRCAssays = append(foreign.R.SRCAssays, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.SRCID == foreign.SRCID {
				local.R.SRC = foreign
				if foreign.R == nil {
					foreign.R = &sourceR{}
				}
				foreign.R.SRCAssays = append(foreign.R.SRCAssays, local)
				break
			}
		}
	}

	return nil
}

// LoadAssayRelationshipType allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (assayL) LoadAssayRelationshipType(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAssay interface{}, mods queries.Applicator) error {
	var slice []*Assay
	var object *Assay

	if singular {
		object = maybeAssay.(*Assay)
	} else {
		slice = *maybeAssay.(*[]*Assay)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &assayR{}
		}
		if !queries.IsNil(object.RelationshipType) {
			args = append(args, object.RelationshipType)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &assayR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.RelationshipType) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.RelationshipType) {
				args = append(args, obj.RelationshipType)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`relationship_type`),
		qm.WhereIn(`relationship_type.relationship_type in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load RelationshipType")
	}

	var resultSlice []*RelationshipType
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice RelationshipType")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for relationship_type")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for relationship_type")
	}

	if len(assayAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.AssayRelationshipType = foreign
		if foreign.R == nil {
			foreign.R = &relationshipTypeR{}
		}
		foreign.R.Assays = append(foreign.R.Assays, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.RelationshipType, foreign.RelationshipType) {
				local.R.AssayRelationshipType = foreign
				if foreign.R == nil {
					foreign.R = &relationshipTypeR{}
				}
				foreign.R.Assays = append(foreign.R.Assays, local)
				break
			}
		}
	}

	return nil
}

// LoadDoc allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (assayL) LoadDoc(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAssay interface{}, mods queries.Applicator) error {
	var slice []*Assay
	var object *Assay

	if singular {
		object = maybeAssay.(*Assay)
	} else {
		slice = *maybeAssay.(*[]*Assay)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &assayR{}
		}
		args = append(args, object.DocID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &assayR{}
			}

			for _, a := range args {
				if a == obj.DocID {
					continue Outer
				}
			}

			args = append(args, obj.DocID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`docs`),
		qm.WhereIn(`docs.doc_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Doc")
	}

	var resultSlice []*Doc
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Doc")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for docs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for docs")
	}

	if len(assayAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Doc = foreign
		if foreign.R == nil {
			foreign.R = &docR{}
		}
		foreign.R.Assays = append(foreign.R.Assays, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.DocID == foreign.DocID {
				local.R.Doc = foreign
				if foreign.R == nil {
					foreign.R = &docR{}
				}
				foreign.R.Assays = append(foreign.R.Assays, local)
				break
			}
		}
	}

	return nil
}

// LoadCuratedByCurationLookup allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (assayL) LoadCuratedByCurationLookup(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAssay interface{}, mods queries.Applicator) error {
	var slice []*Assay
	var object *Assay

	if singular {
		object = maybeAssay.(*Assay)
	} else {
		slice = *maybeAssay.(*[]*Assay)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &assayR{}
		}
		if !queries.IsNil(object.CuratedBy) {
			args = append(args, object.CuratedBy)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &assayR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CuratedBy) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CuratedBy) {
				args = append(args, obj.CuratedBy)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`curation_lookup`),
		qm.WhereIn(`curation_lookup.curated_by in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CurationLookup")
	}

	var resultSlice []*CurationLookup
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CurationLookup")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for curation_lookup")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for curation_lookup")
	}

	if len(assayAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.CuratedByCurationLookup = foreign
		if foreign.R == nil {
			foreign.R = &curationLookupR{}
		}
		foreign.R.CuratedByAssays = append(foreign.R.CuratedByAssays, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CuratedBy, foreign.CuratedBy) {
				local.R.CuratedByCurationLookup = foreign
				if foreign.R == nil {
					foreign.R = &curationLookupR{}
				}
				foreign.R.CuratedByAssays = append(foreign.R.CuratedByAssays, local)
				break
			}
		}
	}

	return nil
}

// LoadConfidenceScoreConfidenceScoreLookup allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (assayL) LoadConfidenceScoreConfidenceScoreLookup(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAssay interface{}, mods queries.Applicator) error {
	var slice []*Assay
	var object *Assay

	if singular {
		object = maybeAssay.(*Assay)
	} else {
		slice = *maybeAssay.(*[]*Assay)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &assayR{}
		}
		if !queries.IsNil(object.ConfidenceScore) {
			args = append(args, object.ConfidenceScore)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &assayR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ConfidenceScore) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.ConfidenceScore) {
				args = append(args, obj.ConfidenceScore)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`confidence_score_lookup`),
		qm.WhereIn(`confidence_score_lookup.confidence_score in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ConfidenceScoreLookup")
	}

	var resultSlice []*ConfidenceScoreLookup
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ConfidenceScoreLookup")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for confidence_score_lookup")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for confidence_score_lookup")
	}

	if len(assayAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.ConfidenceScoreConfidenceScoreLookup = foreign
		if foreign.R == nil {
			foreign.R = &confidenceScoreLookupR{}
		}
		foreign.R.ConfidenceScoreAssays = append(foreign.R.ConfidenceScoreAssays, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.ConfidenceScore, foreign.ConfidenceScore) {
				local.R.ConfidenceScoreConfidenceScoreLookup = foreign
				if foreign.R == nil {
					foreign.R = &confidenceScoreLookupR{}
				}
				foreign.R.ConfidenceScoreAssays = append(foreign.R.ConfidenceScoreAssays, local)
				break
			}
		}
	}

	return nil
}

// LoadChembl allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (assayL) LoadChembl(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAssay interface{}, mods queries.Applicator) error {
	var slice []*Assay
	var object *Assay

	if singular {
		object = maybeAssay.(*Assay)
	} else {
		slice = *maybeAssay.(*[]*Assay)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &assayR{}
		}
		args = append(args, object.ChemblID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &assayR{}
			}

			for _, a := range args {
				if a == obj.ChemblID {
					continue Outer
				}
			}

			args = append(args, obj.ChemblID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`chembl_id_lookup`),
		qm.WhereIn(`chembl_id_lookup.chembl_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ChemblIDLookup")
	}

	var resultSlice []*ChemblIDLookup
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ChemblIDLookup")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for chembl_id_lookup")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for chembl_id_lookup")
	}

	if len(assayAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Chembl = foreign
		if foreign.R == nil {
			foreign.R = &chemblIDLookupR{}
		}
		foreign.R.ChemblAssay = object
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ChemblID == foreign.ChemblID {
				local.R.Chembl = foreign
				if foreign.R == nil {
					foreign.R = &chemblIDLookupR{}
				}
				foreign.R.ChemblAssay = local
				break
			}
		}
	}

	return nil
}

// LoadCell allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (assayL) LoadCell(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAssay interface{}, mods queries.Applicator) error {
	var slice []*Assay
	var object *Assay

	if singular {
		object = maybeAssay.(*Assay)
	} else {
		slice = *maybeAssay.(*[]*Assay)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &assayR{}
		}
		if !queries.IsNil(object.CellID) {
			args = append(args, object.CellID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &assayR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.CellID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.CellID) {
				args = append(args, obj.CellID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`cell_dictionary`),
		qm.WhereIn(`cell_dictionary.cell_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CellDictionary")
	}

	var resultSlice []*CellDictionary
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CellDictionary")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for cell_dictionary")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for cell_dictionary")
	}

	if len(assayAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Cell = foreign
		if foreign.R == nil {
			foreign.R = &cellDictionaryR{}
		}
		foreign.R.CellAssays = append(foreign.R.CellAssays, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.CellID, foreign.CellID) {
				local.R.Cell = foreign
				if foreign.R == nil {
					foreign.R = &cellDictionaryR{}
				}
				foreign.R.CellAssays = append(foreign.R.CellAssays, local)
				break
			}
		}
	}

	return nil
}

// LoadAssayAssayType allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (assayL) LoadAssayAssayType(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAssay interface{}, mods queries.Applicator) error {
	var slice []*Assay
	var object *Assay

	if singular {
		object = maybeAssay.(*Assay)
	} else {
		slice = *maybeAssay.(*[]*Assay)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &assayR{}
		}
		if !queries.IsNil(object.AssayType) {
			args = append(args, object.AssayType)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &assayR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.AssayType) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.AssayType) {
				args = append(args, obj.AssayType)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`assay_type`),
		qm.WhereIn(`assay_type.assay_type in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load AssayType")
	}

	var resultSlice []*AssayType
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice AssayType")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for assay_type")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for assay_type")
	}

	if len(assayAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.AssayAssayType = foreign
		if foreign.R == nil {
			foreign.R = &assayTypeR{}
		}
		foreign.R.Assays = append(foreign.R.Assays, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.AssayType, foreign.AssayType) {
				local.R.AssayAssayType = foreign
				if foreign.R == nil {
					foreign.R = &assayTypeR{}
				}
				foreign.R.Assays = append(foreign.R.Assays, local)
				break
			}
		}
	}

	return nil
}

// LoadActivities allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (assayL) LoadActivities(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAssay interface{}, mods queries.Applicator) error {
	var slice []*Assay
	var object *Assay

	if singular {
		object = maybeAssay.(*Assay)
	} else {
		slice = *maybeAssay.(*[]*Assay)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &assayR{}
		}
		args = append(args, object.AssayID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &assayR{}
			}

			for _, a := range args {
				if a == obj.AssayID {
					continue Outer
				}
			}

			args = append(args, obj.AssayID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`activities`),
		qm.WhereIn(`activities.assay_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load activities")
	}

	var resultSlice []*Activity
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice activities")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on activities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for activities")
	}

	if len(activityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Activities = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &activityR{}
			}
			foreign.R.Assay = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AssayID == foreign.AssayID {
				local.R.Activities = append(local.R.Activities, foreign)
				if foreign.R == nil {
					foreign.R = &activityR{}
				}
				foreign.R.Assay = local
				break
			}
		}
	}

	return nil
}

// LoadAssayClassMaps allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (assayL) LoadAssayClassMaps(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAssay interface{}, mods queries.Applicator) error {
	var slice []*Assay
	var object *Assay

	if singular {
		object = maybeAssay.(*Assay)
	} else {
		slice = *maybeAssay.(*[]*Assay)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &assayR{}
		}
		args = append(args, object.AssayID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &assayR{}
			}

			for _, a := range args {
				if a == obj.AssayID {
					continue Outer
				}
			}

			args = append(args, obj.AssayID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`assay_class_map`),
		qm.WhereIn(`assay_class_map.assay_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load assay_class_map")
	}

	var resultSlice []*AssayClassMap
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice assay_class_map")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on assay_class_map")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for assay_class_map")
	}

	if len(assayClassMapAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AssayClassMaps = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &assayClassMapR{}
			}
			foreign.R.Assay = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AssayID == foreign.AssayID {
				local.R.AssayClassMaps = append(local.R.AssayClassMaps, foreign)
				if foreign.R == nil {
					foreign.R = &assayClassMapR{}
				}
				foreign.R.Assay = local
				break
			}
		}
	}

	return nil
}

// LoadAssayParameters allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (assayL) LoadAssayParameters(ctx context.Context, e boil.ContextExecutor, singular bool, maybeAssay interface{}, mods queries.Applicator) error {
	var slice []*Assay
	var object *Assay

	if singular {
		object = maybeAssay.(*Assay)
	} else {
		slice = *maybeAssay.(*[]*Assay)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &assayR{}
		}
		args = append(args, object.AssayID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &assayR{}
			}

			for _, a := range args {
				if a == obj.AssayID {
					continue Outer
				}
			}

			args = append(args, obj.AssayID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`assay_parameters`),
		qm.WhereIn(`assay_parameters.assay_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load assay_parameters")
	}

	var resultSlice []*AssayParameter
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice assay_parameters")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on assay_parameters")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for assay_parameters")
	}

	if len(assayParameterAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AssayParameters = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &assayParameterR{}
			}
			foreign.R.Assay = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.AssayID == foreign.AssayID {
				local.R.AssayParameters = append(local.R.AssayParameters, foreign)
				if foreign.R == nil {
					foreign.R = &assayParameterR{}
				}
				foreign.R.Assay = local
				break
			}
		}
	}

	return nil
}

// SetBaoFormatBioassayOntology of the assay to the related item.
// Sets o.R.BaoFormatBioassayOntology to related.
// Adds o to related.R.BaoFormatAssays.
func (o *Assay) SetBaoFormatBioassayOntology(ctx context.Context, exec boil.ContextExecutor, insert bool, related *BioassayOntology) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"assays\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"bao_format"}),
		strmangle.WhereClause("\"", "\"", 0, assayPrimaryKeyColumns),
	)
	values := []interface{}{related.BaoID, o.AssayID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BaoFormat, related.BaoID)
	if o.R == nil {
		o.R = &assayR{
			BaoFormatBioassayOntology: related,
		}
	} else {
		o.R.BaoFormatBioassayOntology = related
	}

	if related.R == nil {
		related.R = &bioassayOntologyR{
			BaoFormatAssays: AssaySlice{o},
		}
	} else {
		related.R.BaoFormatAssays = append(related.R.BaoFormatAssays, o)
	}

	return nil
}

// RemoveBaoFormatBioassayOntology relationship.
// Sets o.R.BaoFormatBioassayOntology to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Assay) RemoveBaoFormatBioassayOntology(ctx context.Context, exec boil.ContextExecutor, related *BioassayOntology) error {
	var err error

	queries.SetScanner(&o.BaoFormat, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("bao_format")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BaoFormatBioassayOntology = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.BaoFormatAssays {
		if queries.Equal(o.BaoFormat, ri.BaoFormat) {
			continue
		}

		ln := len(related.R.BaoFormatAssays)
		if ln > 1 && i < ln-1 {
			related.R.BaoFormatAssays[i] = related.R.BaoFormatAssays[ln-1]
		}
		related.R.BaoFormatAssays = related.R.BaoFormatAssays[:ln-1]
		break
	}
	return nil
}

// SetVariant of the assay to the related item.
// Sets o.R.Variant to related.
// Adds o to related.R.VariantAssays.
func (o *Assay) SetVariant(ctx context.Context, exec boil.ContextExecutor, insert bool, related *VariantSequence) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"assays\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"variant_id"}),
		strmangle.WhereClause("\"", "\"", 0, assayPrimaryKeyColumns),
	)
	values := []interface{}{related.VariantID, o.AssayID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.VariantID, related.VariantID)
	if o.R == nil {
		o.R = &assayR{
			Variant: related,
		}
	} else {
		o.R.Variant = related
	}

	if related.R == nil {
		related.R = &variantSequenceR{
			VariantAssays: AssaySlice{o},
		}
	} else {
		related.R.VariantAssays = append(related.R.VariantAssays, o)
	}

	return nil
}

// RemoveVariant relationship.
// Sets o.R.Variant to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Assay) RemoveVariant(ctx context.Context, exec boil.ContextExecutor, related *VariantSequence) error {
	var err error

	queries.SetScanner(&o.VariantID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("variant_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Variant = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.VariantAssays {
		if queries.Equal(o.VariantID, ri.VariantID) {
			continue
		}

		ln := len(related.R.VariantAssays)
		if ln > 1 && i < ln-1 {
			related.R.VariantAssays[i] = related.R.VariantAssays[ln-1]
		}
		related.R.VariantAssays = related.R.VariantAssays[:ln-1]
		break
	}
	return nil
}

// SetTissue of the assay to the related item.
// Sets o.R.Tissue to related.
// Adds o to related.R.TissueAssays.
func (o *Assay) SetTissue(ctx context.Context, exec boil.ContextExecutor, insert bool, related *TissueDictionary) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"assays\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"tissue_id"}),
		strmangle.WhereClause("\"", "\"", 0, assayPrimaryKeyColumns),
	)
	values := []interface{}{related.TissueID, o.AssayID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.TissueID, related.TissueID)
	if o.R == nil {
		o.R = &assayR{
			Tissue: related,
		}
	} else {
		o.R.Tissue = related
	}

	if related.R == nil {
		related.R = &tissueDictionaryR{
			TissueAssays: AssaySlice{o},
		}
	} else {
		related.R.TissueAssays = append(related.R.TissueAssays, o)
	}

	return nil
}

// RemoveTissue relationship.
// Sets o.R.Tissue to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Assay) RemoveTissue(ctx context.Context, exec boil.ContextExecutor, related *TissueDictionary) error {
	var err error

	queries.SetScanner(&o.TissueID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("tissue_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Tissue = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.TissueAssays {
		if queries.Equal(o.TissueID, ri.TissueID) {
			continue
		}

		ln := len(related.R.TissueAssays)
		if ln > 1 && i < ln-1 {
			related.R.TissueAssays[i] = related.R.TissueAssays[ln-1]
		}
		related.R.TissueAssays = related.R.TissueAssays[:ln-1]
		break
	}
	return nil
}

// SetTidTargetDictionary of the assay to the related item.
// Sets o.R.TidTargetDictionary to related.
// Adds o to related.R.TidAssays.
func (o *Assay) SetTidTargetDictionary(ctx context.Context, exec boil.ContextExecutor, insert bool, related *TargetDictionary) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"assays\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"tid"}),
		strmangle.WhereClause("\"", "\"", 0, assayPrimaryKeyColumns),
	)
	values := []interface{}{related.Tid, o.AssayID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Tid, related.Tid)
	if o.R == nil {
		o.R = &assayR{
			TidTargetDictionary: related,
		}
	} else {
		o.R.TidTargetDictionary = related
	}

	if related.R == nil {
		related.R = &targetDictionaryR{
			TidAssays: AssaySlice{o},
		}
	} else {
		related.R.TidAssays = append(related.R.TidAssays, o)
	}

	return nil
}

// RemoveTidTargetDictionary relationship.
// Sets o.R.TidTargetDictionary to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Assay) RemoveTidTargetDictionary(ctx context.Context, exec boil.ContextExecutor, related *TargetDictionary) error {
	var err error

	queries.SetScanner(&o.Tid, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("tid")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.TidTargetDictionary = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.TidAssays {
		if queries.Equal(o.Tid, ri.Tid) {
			continue
		}

		ln := len(related.R.TidAssays)
		if ln > 1 && i < ln-1 {
			related.R.TidAssays[i] = related.R.TidAssays[ln-1]
		}
		related.R.TidAssays = related.R.TidAssays[:ln-1]
		break
	}
	return nil
}

// SetSRC of the assay to the related item.
// Sets o.R.SRC to related.
// Adds o to related.R.SRCAssays.
func (o *Assay) SetSRC(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Source) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"assays\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"src_id"}),
		strmangle.WhereClause("\"", "\"", 0, assayPrimaryKeyColumns),
	)
	values := []interface{}{related.SRCID, o.AssayID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.SRCID = related.SRCID
	if o.R == nil {
		o.R = &assayR{
			SRC: related,
		}
	} else {
		o.R.SRC = related
	}

	if related.R == nil {
		related.R = &sourceR{
			SRCAssays: AssaySlice{o},
		}
	} else {
		related.R.SRCAssays = append(related.R.SRCAssays, o)
	}

	return nil
}

// SetAssayRelationshipType of the assay to the related item.
// Sets o.R.AssayRelationshipType to related.
// Adds o to related.R.Assays.
func (o *Assay) SetAssayRelationshipType(ctx context.Context, exec boil.ContextExecutor, insert bool, related *RelationshipType) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"assays\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"relationship_type"}),
		strmangle.WhereClause("\"", "\"", 0, assayPrimaryKeyColumns),
	)
	values := []interface{}{related.RelationshipType, o.AssayID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.RelationshipType, related.RelationshipType)
	if o.R == nil {
		o.R = &assayR{
			AssayRelationshipType: related,
		}
	} else {
		o.R.AssayRelationshipType = related
	}

	if related.R == nil {
		related.R = &relationshipTypeR{
			Assays: AssaySlice{o},
		}
	} else {
		related.R.Assays = append(related.R.Assays, o)
	}

	return nil
}

// RemoveAssayRelationshipType relationship.
// Sets o.R.AssayRelationshipType to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Assay) RemoveAssayRelationshipType(ctx context.Context, exec boil.ContextExecutor, related *RelationshipType) error {
	var err error

	queries.SetScanner(&o.RelationshipType, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("relationship_type")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.AssayRelationshipType = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Assays {
		if queries.Equal(o.RelationshipType, ri.RelationshipType) {
			continue
		}

		ln := len(related.R.Assays)
		if ln > 1 && i < ln-1 {
			related.R.Assays[i] = related.R.Assays[ln-1]
		}
		related.R.Assays = related.R.Assays[:ln-1]
		break
	}
	return nil
}

// SetDoc of the assay to the related item.
// Sets o.R.Doc to related.
// Adds o to related.R.Assays.
func (o *Assay) SetDoc(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Doc) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"assays\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"doc_id"}),
		strmangle.WhereClause("\"", "\"", 0, assayPrimaryKeyColumns),
	)
	values := []interface{}{related.DocID, o.AssayID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.DocID = related.DocID
	if o.R == nil {
		o.R = &assayR{
			Doc: related,
		}
	} else {
		o.R.Doc = related
	}

	if related.R == nil {
		related.R = &docR{
			Assays: AssaySlice{o},
		}
	} else {
		related.R.Assays = append(related.R.Assays, o)
	}

	return nil
}

// SetCuratedByCurationLookup of the assay to the related item.
// Sets o.R.CuratedByCurationLookup to related.
// Adds o to related.R.CuratedByAssays.
func (o *Assay) SetCuratedByCurationLookup(ctx context.Context, exec boil.ContextExecutor, insert bool, related *CurationLookup) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"assays\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"curated_by"}),
		strmangle.WhereClause("\"", "\"", 0, assayPrimaryKeyColumns),
	)
	values := []interface{}{related.CuratedBy, o.AssayID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CuratedBy, related.CuratedBy)
	if o.R == nil {
		o.R = &assayR{
			CuratedByCurationLookup: related,
		}
	} else {
		o.R.CuratedByCurationLookup = related
	}

	if related.R == nil {
		related.R = &curationLookupR{
			CuratedByAssays: AssaySlice{o},
		}
	} else {
		related.R.CuratedByAssays = append(related.R.CuratedByAssays, o)
	}

	return nil
}

// RemoveCuratedByCurationLookup relationship.
// Sets o.R.CuratedByCurationLookup to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Assay) RemoveCuratedByCurationLookup(ctx context.Context, exec boil.ContextExecutor, related *CurationLookup) error {
	var err error

	queries.SetScanner(&o.CuratedBy, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("curated_by")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.CuratedByCurationLookup = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CuratedByAssays {
		if queries.Equal(o.CuratedBy, ri.CuratedBy) {
			continue
		}

		ln := len(related.R.CuratedByAssays)
		if ln > 1 && i < ln-1 {
			related.R.CuratedByAssays[i] = related.R.CuratedByAssays[ln-1]
		}
		related.R.CuratedByAssays = related.R.CuratedByAssays[:ln-1]
		break
	}
	return nil
}

// SetConfidenceScoreConfidenceScoreLookup of the assay to the related item.
// Sets o.R.ConfidenceScoreConfidenceScoreLookup to related.
// Adds o to related.R.ConfidenceScoreAssays.
func (o *Assay) SetConfidenceScoreConfidenceScoreLookup(ctx context.Context, exec boil.ContextExecutor, insert bool, related *ConfidenceScoreLookup) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"assays\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"confidence_score"}),
		strmangle.WhereClause("\"", "\"", 0, assayPrimaryKeyColumns),
	)
	values := []interface{}{related.ConfidenceScore, o.AssayID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.ConfidenceScore, related.ConfidenceScore)
	if o.R == nil {
		o.R = &assayR{
			ConfidenceScoreConfidenceScoreLookup: related,
		}
	} else {
		o.R.ConfidenceScoreConfidenceScoreLookup = related
	}

	if related.R == nil {
		related.R = &confidenceScoreLookupR{
			ConfidenceScoreAssays: AssaySlice{o},
		}
	} else {
		related.R.ConfidenceScoreAssays = append(related.R.ConfidenceScoreAssays, o)
	}

	return nil
}

// RemoveConfidenceScoreConfidenceScoreLookup relationship.
// Sets o.R.ConfidenceScoreConfidenceScoreLookup to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Assay) RemoveConfidenceScoreConfidenceScoreLookup(ctx context.Context, exec boil.ContextExecutor, related *ConfidenceScoreLookup) error {
	var err error

	queries.SetScanner(&o.ConfidenceScore, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("confidence_score")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.ConfidenceScoreConfidenceScoreLookup = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.ConfidenceScoreAssays {
		if queries.Equal(o.ConfidenceScore, ri.ConfidenceScore) {
			continue
		}

		ln := len(related.R.ConfidenceScoreAssays)
		if ln > 1 && i < ln-1 {
			related.R.ConfidenceScoreAssays[i] = related.R.ConfidenceScoreAssays[ln-1]
		}
		related.R.ConfidenceScoreAssays = related.R.ConfidenceScoreAssays[:ln-1]
		break
	}
	return nil
}

// SetChembl of the assay to the related item.
// Sets o.R.Chembl to related.
// Adds o to related.R.ChemblAssay.
func (o *Assay) SetChembl(ctx context.Context, exec boil.ContextExecutor, insert bool, related *ChemblIDLookup) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"assays\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"chembl_id"}),
		strmangle.WhereClause("\"", "\"", 0, assayPrimaryKeyColumns),
	)
	values := []interface{}{related.ChemblID, o.AssayID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ChemblID = related.ChemblID
	if o.R == nil {
		o.R = &assayR{
			Chembl: related,
		}
	} else {
		o.R.Chembl = related
	}

	if related.R == nil {
		related.R = &chemblIDLookupR{
			ChemblAssay: o,
		}
	} else {
		related.R.ChemblAssay = o
	}

	return nil
}

// SetCell of the assay to the related item.
// Sets o.R.Cell to related.
// Adds o to related.R.CellAssays.
func (o *Assay) SetCell(ctx context.Context, exec boil.ContextExecutor, insert bool, related *CellDictionary) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"assays\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"cell_id"}),
		strmangle.WhereClause("\"", "\"", 0, assayPrimaryKeyColumns),
	)
	values := []interface{}{related.CellID, o.AssayID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.CellID, related.CellID)
	if o.R == nil {
		o.R = &assayR{
			Cell: related,
		}
	} else {
		o.R.Cell = related
	}

	if related.R == nil {
		related.R = &cellDictionaryR{
			CellAssays: AssaySlice{o},
		}
	} else {
		related.R.CellAssays = append(related.R.CellAssays, o)
	}

	return nil
}

// RemoveCell relationship.
// Sets o.R.Cell to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Assay) RemoveCell(ctx context.Context, exec boil.ContextExecutor, related *CellDictionary) error {
	var err error

	queries.SetScanner(&o.CellID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("cell_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Cell = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.CellAssays {
		if queries.Equal(o.CellID, ri.CellID) {
			continue
		}

		ln := len(related.R.CellAssays)
		if ln > 1 && i < ln-1 {
			related.R.CellAssays[i] = related.R.CellAssays[ln-1]
		}
		related.R.CellAssays = related.R.CellAssays[:ln-1]
		break
	}
	return nil
}

// SetAssayAssayType of the assay to the related item.
// Sets o.R.AssayAssayType to related.
// Adds o to related.R.Assays.
func (o *Assay) SetAssayAssayType(ctx context.Context, exec boil.ContextExecutor, insert bool, related *AssayType) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"assays\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"assay_type"}),
		strmangle.WhereClause("\"", "\"", 0, assayPrimaryKeyColumns),
	)
	values := []interface{}{related.AssayType, o.AssayID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.AssayType, related.AssayType)
	if o.R == nil {
		o.R = &assayR{
			AssayAssayType: related,
		}
	} else {
		o.R.AssayAssayType = related
	}

	if related.R == nil {
		related.R = &assayTypeR{
			Assays: AssaySlice{o},
		}
	} else {
		related.R.Assays = append(related.R.Assays, o)
	}

	return nil
}

// RemoveAssayAssayType relationship.
// Sets o.R.AssayAssayType to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Assay) RemoveAssayAssayType(ctx context.Context, exec boil.ContextExecutor, related *AssayType) error {
	var err error

	queries.SetScanner(&o.AssayType, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("assay_type")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.AssayAssayType = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Assays {
		if queries.Equal(o.AssayType, ri.AssayType) {
			continue
		}

		ln := len(related.R.Assays)
		if ln > 1 && i < ln-1 {
			related.R.Assays[i] = related.R.Assays[ln-1]
		}
		related.R.Assays = related.R.Assays[:ln-1]
		break
	}
	return nil
}

// AddActivities adds the given related objects to the existing relationships
// of the assay, optionally inserting them as new records.
// Appends related to o.R.Activities.
// Sets related.R.Assay appropriately.
func (o *Assay) AddActivities(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Activity) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AssayID = o.AssayID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"activities\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"assay_id"}),
				strmangle.WhereClause("\"", "\"", 0, activityPrimaryKeyColumns),
			)
			values := []interface{}{o.AssayID, rel.ActivityID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AssayID = o.AssayID
		}
	}

	if o.R == nil {
		o.R = &assayR{
			Activities: related,
		}
	} else {
		o.R.Activities = append(o.R.Activities, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &activityR{
				Assay: o,
			}
		} else {
			rel.R.Assay = o
		}
	}
	return nil
}

// AddAssayClassMaps adds the given related objects to the existing relationships
// of the assay, optionally inserting them as new records.
// Appends related to o.R.AssayClassMaps.
// Sets related.R.Assay appropriately.
func (o *Assay) AddAssayClassMaps(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AssayClassMap) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AssayID = o.AssayID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"assay_class_map\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"assay_id"}),
				strmangle.WhereClause("\"", "\"", 0, assayClassMapPrimaryKeyColumns),
			)
			values := []interface{}{o.AssayID, rel.AssCLSMapID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AssayID = o.AssayID
		}
	}

	if o.R == nil {
		o.R = &assayR{
			AssayClassMaps: related,
		}
	} else {
		o.R.AssayClassMaps = append(o.R.AssayClassMaps, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &assayClassMapR{
				Assay: o,
			}
		} else {
			rel.R.Assay = o
		}
	}
	return nil
}

// AddAssayParameters adds the given related objects to the existing relationships
// of the assay, optionally inserting them as new records.
// Appends related to o.R.AssayParameters.
// Sets related.R.Assay appropriately.
func (o *Assay) AddAssayParameters(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AssayParameter) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.AssayID = o.AssayID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"assay_parameters\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"assay_id"}),
				strmangle.WhereClause("\"", "\"", 0, assayParameterPrimaryKeyColumns),
			)
			values := []interface{}{o.AssayID, rel.AssayParamID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.AssayID = o.AssayID
		}
	}

	if o.R == nil {
		o.R = &assayR{
			AssayParameters: related,
		}
	} else {
		o.R.AssayParameters = append(o.R.AssayParameters, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &assayParameterR{
				Assay: o,
			}
		} else {
			rel.R.Assay = o
		}
	}
	return nil
}

// Assays retrieves all the records using an executor.
func Assays(mods ...qm.QueryMod) assayQuery {
	mods = append(mods, qm.From("\"assays\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"assays\".*"})
	}

	return assayQuery{q}
}

// FindAssay retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindAssay(ctx context.Context, exec boil.ContextExecutor, assayID int64, selectCols ...string) (*Assay, error) {
	assayObj := &Assay{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"assays\" where \"assay_id\"=?", sel,
	)

	q := queries.Raw(query, assayID)

	err := q.Bind(ctx, exec, assayObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from assays")
	}

	if err = assayObj.doAfterSelectHooks(ctx, exec); err != nil {
		return assayObj, err
	}

	return assayObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Assay) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no assays provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(assayColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	assayInsertCacheMut.RLock()
	cache, cached := assayInsertCache[key]
	assayInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			assayAllColumns,
			assayColumnsWithDefault,
			assayColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(assayType, assayMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(assayType, assayMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"assays\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"assays\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into assays")
	}

	if !cached {
		assayInsertCacheMut.Lock()
		assayInsertCache[key] = cache
		assayInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Assay.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Assay) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	assayUpdateCacheMut.RLock()
	cache, cached := assayUpdateCache[key]
	assayUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			assayAllColumns,
			assayPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update assays, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"assays\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 0, wl),
			strmangle.WhereClause("\"", "\"", 0, assayPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(assayType, assayMapping, append(wl, assayPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update assays row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for assays")
	}

	if !cached {
		assayUpdateCacheMut.Lock()
		assayUpdateCache[key] = cache
		assayUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q assayQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for assays")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for assays")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o AssaySlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), assayPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"assays\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, assayPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in assay slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all assay")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Assay) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no assays provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(assayColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	assayUpsertCacheMut.RLock()
	cache, cached := assayUpsertCache[key]
	assayUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			assayAllColumns,
			assayColumnsWithDefault,
			assayColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			assayAllColumns,
			assayPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert assays, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(assayPrimaryKeyColumns))
			copy(conflict, assayPrimaryKeyColumns)
		}
		cache.query = buildUpsertQuerySQLite(dialect, "\"assays\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(assayType, assayMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(assayType, assayMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert assays")
	}

	if !cached {
		assayUpsertCacheMut.Lock()
		assayUpsertCache[key] = cache
		assayUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Assay record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Assay) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Assay provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), assayPrimaryKeyMapping)
	sql := "DELETE FROM \"assays\" WHERE \"assay_id\"=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from assays")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for assays")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q assayQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no assayQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from assays")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for assays")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o AssaySlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(assayBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), assayPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"assays\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, assayPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from assay slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for assays")
	}

	if len(assayAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Assay) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindAssay(ctx, exec, o.AssayID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *AssaySlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := AssaySlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), assayPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"assays\".* FROM \"assays\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, assayPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in AssaySlice")
	}

	*o = slice

	return nil
}

// AssayExists checks if the Assay row exists.
func AssayExists(ctx context.Context, exec boil.ContextExecutor, assayID int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"assays\" where \"assay_id\"=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, assayID)
	}
	row := exec.QueryRowContext(ctx, sql, assayID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if assays exists")
	}

	return exists, nil
}
