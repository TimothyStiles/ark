// Code generated by SQLBoiler 4.11.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// MoleculeDictionary is an object representing the database table.
type MoleculeDictionary struct {
	Molregno           int64       `boil:"molregno" json:"molregno" toml:"molregno" yaml:"molregno"`
	PrefName           null.String `boil:"pref_name" json:"pref_name,omitempty" toml:"pref_name" yaml:"pref_name,omitempty"`
	ChemblID           string      `boil:"chembl_id" json:"chembl_id" toml:"chembl_id" yaml:"chembl_id"`
	MaxPhase           int16       `boil:"max_phase" json:"max_phase" toml:"max_phase" yaml:"max_phase"`
	TherapeuticFlag    int16       `boil:"therapeutic_flag" json:"therapeutic_flag" toml:"therapeutic_flag" yaml:"therapeutic_flag"`
	DosedIngredient    int16       `boil:"dosed_ingredient" json:"dosed_ingredient" toml:"dosed_ingredient" yaml:"dosed_ingredient"`
	StructureType      string      `boil:"structure_type" json:"structure_type" toml:"structure_type" yaml:"structure_type"`
	ChebiParID         null.Int64  `boil:"chebi_par_id" json:"chebi_par_id,omitempty" toml:"chebi_par_id" yaml:"chebi_par_id,omitempty"`
	MoleculeType       null.String `boil:"molecule_type" json:"molecule_type,omitempty" toml:"molecule_type" yaml:"molecule_type,omitempty"`
	FirstApproval      null.Int64  `boil:"first_approval" json:"first_approval,omitempty" toml:"first_approval" yaml:"first_approval,omitempty"`
	Oral               int16       `boil:"oral" json:"oral" toml:"oral" yaml:"oral"`
	Parenteral         int16       `boil:"parenteral" json:"parenteral" toml:"parenteral" yaml:"parenteral"`
	Topical            int16       `boil:"topical" json:"topical" toml:"topical" yaml:"topical"`
	BlackBoxWarning    int16       `boil:"black_box_warning" json:"black_box_warning" toml:"black_box_warning" yaml:"black_box_warning"`
	NaturalProduct     int16       `boil:"natural_product" json:"natural_product" toml:"natural_product" yaml:"natural_product"`
	FirstInClass       int16       `boil:"first_in_class" json:"first_in_class" toml:"first_in_class" yaml:"first_in_class"`
	Chirality          int16       `boil:"chirality" json:"chirality" toml:"chirality" yaml:"chirality"`
	Prodrug            int16       `boil:"prodrug" json:"prodrug" toml:"prodrug" yaml:"prodrug"`
	InorganicFlag      int16       `boil:"inorganic_flag" json:"inorganic_flag" toml:"inorganic_flag" yaml:"inorganic_flag"`
	UsanYear           null.Int64  `boil:"usan_year" json:"usan_year,omitempty" toml:"usan_year" yaml:"usan_year,omitempty"`
	AvailabilityType   null.Int16  `boil:"availability_type" json:"availability_type,omitempty" toml:"availability_type" yaml:"availability_type,omitempty"`
	UsanStem           null.String `boil:"usan_stem" json:"usan_stem,omitempty" toml:"usan_stem" yaml:"usan_stem,omitempty"`
	PolymerFlag        null.Int16  `boil:"polymer_flag" json:"polymer_flag,omitempty" toml:"polymer_flag" yaml:"polymer_flag,omitempty"`
	UsanSubstem        null.String `boil:"usan_substem" json:"usan_substem,omitempty" toml:"usan_substem" yaml:"usan_substem,omitempty"`
	UsanStemDefinition null.String `boil:"usan_stem_definition" json:"usan_stem_definition,omitempty" toml:"usan_stem_definition" yaml:"usan_stem_definition,omitempty"`
	IndicationClass    null.String `boil:"indication_class" json:"indication_class,omitempty" toml:"indication_class" yaml:"indication_class,omitempty"`
	WithdrawnFlag      int16       `boil:"withdrawn_flag" json:"withdrawn_flag" toml:"withdrawn_flag" yaml:"withdrawn_flag"`
	WithdrawnYear      null.Int64  `boil:"withdrawn_year" json:"withdrawn_year,omitempty" toml:"withdrawn_year" yaml:"withdrawn_year,omitempty"`
	WithdrawnCountry   null.String `boil:"withdrawn_country" json:"withdrawn_country,omitempty" toml:"withdrawn_country" yaml:"withdrawn_country,omitempty"`
	WithdrawnReason    null.String `boil:"withdrawn_reason" json:"withdrawn_reason,omitempty" toml:"withdrawn_reason" yaml:"withdrawn_reason,omitempty"`
	WithdrawnClass     null.String `boil:"withdrawn_class" json:"withdrawn_class,omitempty" toml:"withdrawn_class" yaml:"withdrawn_class,omitempty"`

	R *moleculeDictionaryR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L moleculeDictionaryL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var MoleculeDictionaryColumns = struct {
	Molregno           string
	PrefName           string
	ChemblID           string
	MaxPhase           string
	TherapeuticFlag    string
	DosedIngredient    string
	StructureType      string
	ChebiParID         string
	MoleculeType       string
	FirstApproval      string
	Oral               string
	Parenteral         string
	Topical            string
	BlackBoxWarning    string
	NaturalProduct     string
	FirstInClass       string
	Chirality          string
	Prodrug            string
	InorganicFlag      string
	UsanYear           string
	AvailabilityType   string
	UsanStem           string
	PolymerFlag        string
	UsanSubstem        string
	UsanStemDefinition string
	IndicationClass    string
	WithdrawnFlag      string
	WithdrawnYear      string
	WithdrawnCountry   string
	WithdrawnReason    string
	WithdrawnClass     string
}{
	Molregno:           "molregno",
	PrefName:           "pref_name",
	ChemblID:           "chembl_id",
	MaxPhase:           "max_phase",
	TherapeuticFlag:    "therapeutic_flag",
	DosedIngredient:    "dosed_ingredient",
	StructureType:      "structure_type",
	ChebiParID:         "chebi_par_id",
	MoleculeType:       "molecule_type",
	FirstApproval:      "first_approval",
	Oral:               "oral",
	Parenteral:         "parenteral",
	Topical:            "topical",
	BlackBoxWarning:    "black_box_warning",
	NaturalProduct:     "natural_product",
	FirstInClass:       "first_in_class",
	Chirality:          "chirality",
	Prodrug:            "prodrug",
	InorganicFlag:      "inorganic_flag",
	UsanYear:           "usan_year",
	AvailabilityType:   "availability_type",
	UsanStem:           "usan_stem",
	PolymerFlag:        "polymer_flag",
	UsanSubstem:        "usan_substem",
	UsanStemDefinition: "usan_stem_definition",
	IndicationClass:    "indication_class",
	WithdrawnFlag:      "withdrawn_flag",
	WithdrawnYear:      "withdrawn_year",
	WithdrawnCountry:   "withdrawn_country",
	WithdrawnReason:    "withdrawn_reason",
	WithdrawnClass:     "withdrawn_class",
}

var MoleculeDictionaryTableColumns = struct {
	Molregno           string
	PrefName           string
	ChemblID           string
	MaxPhase           string
	TherapeuticFlag    string
	DosedIngredient    string
	StructureType      string
	ChebiParID         string
	MoleculeType       string
	FirstApproval      string
	Oral               string
	Parenteral         string
	Topical            string
	BlackBoxWarning    string
	NaturalProduct     string
	FirstInClass       string
	Chirality          string
	Prodrug            string
	InorganicFlag      string
	UsanYear           string
	AvailabilityType   string
	UsanStem           string
	PolymerFlag        string
	UsanSubstem        string
	UsanStemDefinition string
	IndicationClass    string
	WithdrawnFlag      string
	WithdrawnYear      string
	WithdrawnCountry   string
	WithdrawnReason    string
	WithdrawnClass     string
}{
	Molregno:           "molecule_dictionary.molregno",
	PrefName:           "molecule_dictionary.pref_name",
	ChemblID:           "molecule_dictionary.chembl_id",
	MaxPhase:           "molecule_dictionary.max_phase",
	TherapeuticFlag:    "molecule_dictionary.therapeutic_flag",
	DosedIngredient:    "molecule_dictionary.dosed_ingredient",
	StructureType:      "molecule_dictionary.structure_type",
	ChebiParID:         "molecule_dictionary.chebi_par_id",
	MoleculeType:       "molecule_dictionary.molecule_type",
	FirstApproval:      "molecule_dictionary.first_approval",
	Oral:               "molecule_dictionary.oral",
	Parenteral:         "molecule_dictionary.parenteral",
	Topical:            "molecule_dictionary.topical",
	BlackBoxWarning:    "molecule_dictionary.black_box_warning",
	NaturalProduct:     "molecule_dictionary.natural_product",
	FirstInClass:       "molecule_dictionary.first_in_class",
	Chirality:          "molecule_dictionary.chirality",
	Prodrug:            "molecule_dictionary.prodrug",
	InorganicFlag:      "molecule_dictionary.inorganic_flag",
	UsanYear:           "molecule_dictionary.usan_year",
	AvailabilityType:   "molecule_dictionary.availability_type",
	UsanStem:           "molecule_dictionary.usan_stem",
	PolymerFlag:        "molecule_dictionary.polymer_flag",
	UsanSubstem:        "molecule_dictionary.usan_substem",
	UsanStemDefinition: "molecule_dictionary.usan_stem_definition",
	IndicationClass:    "molecule_dictionary.indication_class",
	WithdrawnFlag:      "molecule_dictionary.withdrawn_flag",
	WithdrawnYear:      "molecule_dictionary.withdrawn_year",
	WithdrawnCountry:   "molecule_dictionary.withdrawn_country",
	WithdrawnReason:    "molecule_dictionary.withdrawn_reason",
	WithdrawnClass:     "molecule_dictionary.withdrawn_class",
}

// Generated where

var MoleculeDictionaryWhere = struct {
	Molregno           whereHelperint64
	PrefName           whereHelpernull_String
	ChemblID           whereHelperstring
	MaxPhase           whereHelperint16
	TherapeuticFlag    whereHelperint16
	DosedIngredient    whereHelperint16
	StructureType      whereHelperstring
	ChebiParID         whereHelpernull_Int64
	MoleculeType       whereHelpernull_String
	FirstApproval      whereHelpernull_Int64
	Oral               whereHelperint16
	Parenteral         whereHelperint16
	Topical            whereHelperint16
	BlackBoxWarning    whereHelperint16
	NaturalProduct     whereHelperint16
	FirstInClass       whereHelperint16
	Chirality          whereHelperint16
	Prodrug            whereHelperint16
	InorganicFlag      whereHelperint16
	UsanYear           whereHelpernull_Int64
	AvailabilityType   whereHelpernull_Int16
	UsanStem           whereHelpernull_String
	PolymerFlag        whereHelpernull_Int16
	UsanSubstem        whereHelpernull_String
	UsanStemDefinition whereHelpernull_String
	IndicationClass    whereHelpernull_String
	WithdrawnFlag      whereHelperint16
	WithdrawnYear      whereHelpernull_Int64
	WithdrawnCountry   whereHelpernull_String
	WithdrawnReason    whereHelpernull_String
	WithdrawnClass     whereHelpernull_String
}{
	Molregno:           whereHelperint64{field: "\"molecule_dictionary\".\"molregno\""},
	PrefName:           whereHelpernull_String{field: "\"molecule_dictionary\".\"pref_name\""},
	ChemblID:           whereHelperstring{field: "\"molecule_dictionary\".\"chembl_id\""},
	MaxPhase:           whereHelperint16{field: "\"molecule_dictionary\".\"max_phase\""},
	TherapeuticFlag:    whereHelperint16{field: "\"molecule_dictionary\".\"therapeutic_flag\""},
	DosedIngredient:    whereHelperint16{field: "\"molecule_dictionary\".\"dosed_ingredient\""},
	StructureType:      whereHelperstring{field: "\"molecule_dictionary\".\"structure_type\""},
	ChebiParID:         whereHelpernull_Int64{field: "\"molecule_dictionary\".\"chebi_par_id\""},
	MoleculeType:       whereHelpernull_String{field: "\"molecule_dictionary\".\"molecule_type\""},
	FirstApproval:      whereHelpernull_Int64{field: "\"molecule_dictionary\".\"first_approval\""},
	Oral:               whereHelperint16{field: "\"molecule_dictionary\".\"oral\""},
	Parenteral:         whereHelperint16{field: "\"molecule_dictionary\".\"parenteral\""},
	Topical:            whereHelperint16{field: "\"molecule_dictionary\".\"topical\""},
	BlackBoxWarning:    whereHelperint16{field: "\"molecule_dictionary\".\"black_box_warning\""},
	NaturalProduct:     whereHelperint16{field: "\"molecule_dictionary\".\"natural_product\""},
	FirstInClass:       whereHelperint16{field: "\"molecule_dictionary\".\"first_in_class\""},
	Chirality:          whereHelperint16{field: "\"molecule_dictionary\".\"chirality\""},
	Prodrug:            whereHelperint16{field: "\"molecule_dictionary\".\"prodrug\""},
	InorganicFlag:      whereHelperint16{field: "\"molecule_dictionary\".\"inorganic_flag\""},
	UsanYear:           whereHelpernull_Int64{field: "\"molecule_dictionary\".\"usan_year\""},
	AvailabilityType:   whereHelpernull_Int16{field: "\"molecule_dictionary\".\"availability_type\""},
	UsanStem:           whereHelpernull_String{field: "\"molecule_dictionary\".\"usan_stem\""},
	PolymerFlag:        whereHelpernull_Int16{field: "\"molecule_dictionary\".\"polymer_flag\""},
	UsanSubstem:        whereHelpernull_String{field: "\"molecule_dictionary\".\"usan_substem\""},
	UsanStemDefinition: whereHelpernull_String{field: "\"molecule_dictionary\".\"usan_stem_definition\""},
	IndicationClass:    whereHelpernull_String{field: "\"molecule_dictionary\".\"indication_class\""},
	WithdrawnFlag:      whereHelperint16{field: "\"molecule_dictionary\".\"withdrawn_flag\""},
	WithdrawnYear:      whereHelpernull_Int64{field: "\"molecule_dictionary\".\"withdrawn_year\""},
	WithdrawnCountry:   whereHelpernull_String{field: "\"molecule_dictionary\".\"withdrawn_country\""},
	WithdrawnReason:    whereHelpernull_String{field: "\"molecule_dictionary\".\"withdrawn_reason\""},
	WithdrawnClass:     whereHelpernull_String{field: "\"molecule_dictionary\".\"withdrawn_class\""},
}

// MoleculeDictionaryRels is where relationship names are stored.
var MoleculeDictionaryRels = struct {
	Chembl                              string
	MolregnoBiotherapeutic              string
	MolregnoCompoundProperty            string
	MolregnoCompoundStructure           string
	MolregnoMoleculeHierarchy           string
	MolregnoActivities                  string
	MolregnoCompoundRecords             string
	MolregnoCompoundStructuralAlerts    string
	MolregnoDrugIndications             string
	MolregnoDrugMechanisms              string
	MolregnoFormulations                string
	MolregnoMoleculeAtcClassifications  string
	MolregnoMoleculeFracClassifications string
	ParentMolregnoMoleculeHierarchies   string
	ActiveMolregnoMoleculeHierarchies   string
	MolregnoMoleculeHracClassifications string
	MolregnoMoleculeIracClassifications string
	MolregnoMoleculeSynonyms            string
}{
	Chembl:                              "Chembl",
	MolregnoBiotherapeutic:              "MolregnoBiotherapeutic",
	MolregnoCompoundProperty:            "MolregnoCompoundProperty",
	MolregnoCompoundStructure:           "MolregnoCompoundStructure",
	MolregnoMoleculeHierarchy:           "MolregnoMoleculeHierarchy",
	MolregnoActivities:                  "MolregnoActivities",
	MolregnoCompoundRecords:             "MolregnoCompoundRecords",
	MolregnoCompoundStructuralAlerts:    "MolregnoCompoundStructuralAlerts",
	MolregnoDrugIndications:             "MolregnoDrugIndications",
	MolregnoDrugMechanisms:              "MolregnoDrugMechanisms",
	MolregnoFormulations:                "MolregnoFormulations",
	MolregnoMoleculeAtcClassifications:  "MolregnoMoleculeAtcClassifications",
	MolregnoMoleculeFracClassifications: "MolregnoMoleculeFracClassifications",
	ParentMolregnoMoleculeHierarchies:   "ParentMolregnoMoleculeHierarchies",
	ActiveMolregnoMoleculeHierarchies:   "ActiveMolregnoMoleculeHierarchies",
	MolregnoMoleculeHracClassifications: "MolregnoMoleculeHracClassifications",
	MolregnoMoleculeIracClassifications: "MolregnoMoleculeIracClassifications",
	MolregnoMoleculeSynonyms:            "MolregnoMoleculeSynonyms",
}

// moleculeDictionaryR is where relationships are stored.
type moleculeDictionaryR struct {
	Chembl                              *ChemblIDLookup                 `boil:"Chembl" json:"Chembl" toml:"Chembl" yaml:"Chembl"`
	MolregnoBiotherapeutic              *Biotherapeutic                 `boil:"MolregnoBiotherapeutic" json:"MolregnoBiotherapeutic" toml:"MolregnoBiotherapeutic" yaml:"MolregnoBiotherapeutic"`
	MolregnoCompoundProperty            *CompoundProperty               `boil:"MolregnoCompoundProperty" json:"MolregnoCompoundProperty" toml:"MolregnoCompoundProperty" yaml:"MolregnoCompoundProperty"`
	MolregnoCompoundStructure           *CompoundStructure              `boil:"MolregnoCompoundStructure" json:"MolregnoCompoundStructure" toml:"MolregnoCompoundStructure" yaml:"MolregnoCompoundStructure"`
	MolregnoMoleculeHierarchy           *MoleculeHierarchy              `boil:"MolregnoMoleculeHierarchy" json:"MolregnoMoleculeHierarchy" toml:"MolregnoMoleculeHierarchy" yaml:"MolregnoMoleculeHierarchy"`
	MolregnoActivities                  ActivitySlice                   `boil:"MolregnoActivities" json:"MolregnoActivities" toml:"MolregnoActivities" yaml:"MolregnoActivities"`
	MolregnoCompoundRecords             CompoundRecordSlice             `boil:"MolregnoCompoundRecords" json:"MolregnoCompoundRecords" toml:"MolregnoCompoundRecords" yaml:"MolregnoCompoundRecords"`
	MolregnoCompoundStructuralAlerts    CompoundStructuralAlertSlice    `boil:"MolregnoCompoundStructuralAlerts" json:"MolregnoCompoundStructuralAlerts" toml:"MolregnoCompoundStructuralAlerts" yaml:"MolregnoCompoundStructuralAlerts"`
	MolregnoDrugIndications             DrugIndicationSlice             `boil:"MolregnoDrugIndications" json:"MolregnoDrugIndications" toml:"MolregnoDrugIndications" yaml:"MolregnoDrugIndications"`
	MolregnoDrugMechanisms              DrugMechanismSlice              `boil:"MolregnoDrugMechanisms" json:"MolregnoDrugMechanisms" toml:"MolregnoDrugMechanisms" yaml:"MolregnoDrugMechanisms"`
	MolregnoFormulations                FormulationSlice                `boil:"MolregnoFormulations" json:"MolregnoFormulations" toml:"MolregnoFormulations" yaml:"MolregnoFormulations"`
	MolregnoMoleculeAtcClassifications  MoleculeAtcClassificationSlice  `boil:"MolregnoMoleculeAtcClassifications" json:"MolregnoMoleculeAtcClassifications" toml:"MolregnoMoleculeAtcClassifications" yaml:"MolregnoMoleculeAtcClassifications"`
	MolregnoMoleculeFracClassifications MoleculeFracClassificationSlice `boil:"MolregnoMoleculeFracClassifications" json:"MolregnoMoleculeFracClassifications" toml:"MolregnoMoleculeFracClassifications" yaml:"MolregnoMoleculeFracClassifications"`
	ParentMolregnoMoleculeHierarchies   MoleculeHierarchySlice          `boil:"ParentMolregnoMoleculeHierarchies" json:"ParentMolregnoMoleculeHierarchies" toml:"ParentMolregnoMoleculeHierarchies" yaml:"ParentMolregnoMoleculeHierarchies"`
	ActiveMolregnoMoleculeHierarchies   MoleculeHierarchySlice          `boil:"ActiveMolregnoMoleculeHierarchies" json:"ActiveMolregnoMoleculeHierarchies" toml:"ActiveMolregnoMoleculeHierarchies" yaml:"ActiveMolregnoMoleculeHierarchies"`
	MolregnoMoleculeHracClassifications MoleculeHracClassificationSlice `boil:"MolregnoMoleculeHracClassifications" json:"MolregnoMoleculeHracClassifications" toml:"MolregnoMoleculeHracClassifications" yaml:"MolregnoMoleculeHracClassifications"`
	MolregnoMoleculeIracClassifications MoleculeIracClassificationSlice `boil:"MolregnoMoleculeIracClassifications" json:"MolregnoMoleculeIracClassifications" toml:"MolregnoMoleculeIracClassifications" yaml:"MolregnoMoleculeIracClassifications"`
	MolregnoMoleculeSynonyms            MoleculeSynonymSlice            `boil:"MolregnoMoleculeSynonyms" json:"MolregnoMoleculeSynonyms" toml:"MolregnoMoleculeSynonyms" yaml:"MolregnoMoleculeSynonyms"`
}

// NewStruct creates a new relationship struct
func (*moleculeDictionaryR) NewStruct() *moleculeDictionaryR {
	return &moleculeDictionaryR{}
}

func (r *moleculeDictionaryR) GetChembl() *ChemblIDLookup {
	if r == nil {
		return nil
	}
	return r.Chembl
}

func (r *moleculeDictionaryR) GetMolregnoBiotherapeutic() *Biotherapeutic {
	if r == nil {
		return nil
	}
	return r.MolregnoBiotherapeutic
}

func (r *moleculeDictionaryR) GetMolregnoCompoundProperty() *CompoundProperty {
	if r == nil {
		return nil
	}
	return r.MolregnoCompoundProperty
}

func (r *moleculeDictionaryR) GetMolregnoCompoundStructure() *CompoundStructure {
	if r == nil {
		return nil
	}
	return r.MolregnoCompoundStructure
}

func (r *moleculeDictionaryR) GetMolregnoMoleculeHierarchy() *MoleculeHierarchy {
	if r == nil {
		return nil
	}
	return r.MolregnoMoleculeHierarchy
}

func (r *moleculeDictionaryR) GetMolregnoActivities() ActivitySlice {
	if r == nil {
		return nil
	}
	return r.MolregnoActivities
}

func (r *moleculeDictionaryR) GetMolregnoCompoundRecords() CompoundRecordSlice {
	if r == nil {
		return nil
	}
	return r.MolregnoCompoundRecords
}

func (r *moleculeDictionaryR) GetMolregnoCompoundStructuralAlerts() CompoundStructuralAlertSlice {
	if r == nil {
		return nil
	}
	return r.MolregnoCompoundStructuralAlerts
}

func (r *moleculeDictionaryR) GetMolregnoDrugIndications() DrugIndicationSlice {
	if r == nil {
		return nil
	}
	return r.MolregnoDrugIndications
}

func (r *moleculeDictionaryR) GetMolregnoDrugMechanisms() DrugMechanismSlice {
	if r == nil {
		return nil
	}
	return r.MolregnoDrugMechanisms
}

func (r *moleculeDictionaryR) GetMolregnoFormulations() FormulationSlice {
	if r == nil {
		return nil
	}
	return r.MolregnoFormulations
}

func (r *moleculeDictionaryR) GetMolregnoMoleculeAtcClassifications() MoleculeAtcClassificationSlice {
	if r == nil {
		return nil
	}
	return r.MolregnoMoleculeAtcClassifications
}

func (r *moleculeDictionaryR) GetMolregnoMoleculeFracClassifications() MoleculeFracClassificationSlice {
	if r == nil {
		return nil
	}
	return r.MolregnoMoleculeFracClassifications
}

func (r *moleculeDictionaryR) GetParentMolregnoMoleculeHierarchies() MoleculeHierarchySlice {
	if r == nil {
		return nil
	}
	return r.ParentMolregnoMoleculeHierarchies
}

func (r *moleculeDictionaryR) GetActiveMolregnoMoleculeHierarchies() MoleculeHierarchySlice {
	if r == nil {
		return nil
	}
	return r.ActiveMolregnoMoleculeHierarchies
}

func (r *moleculeDictionaryR) GetMolregnoMoleculeHracClassifications() MoleculeHracClassificationSlice {
	if r == nil {
		return nil
	}
	return r.MolregnoMoleculeHracClassifications
}

func (r *moleculeDictionaryR) GetMolregnoMoleculeIracClassifications() MoleculeIracClassificationSlice {
	if r == nil {
		return nil
	}
	return r.MolregnoMoleculeIracClassifications
}

func (r *moleculeDictionaryR) GetMolregnoMoleculeSynonyms() MoleculeSynonymSlice {
	if r == nil {
		return nil
	}
	return r.MolregnoMoleculeSynonyms
}

// moleculeDictionaryL is where Load methods for each relationship are stored.
type moleculeDictionaryL struct{}

var (
	moleculeDictionaryAllColumns            = []string{"molregno", "pref_name", "chembl_id", "max_phase", "therapeutic_flag", "dosed_ingredient", "structure_type", "chebi_par_id", "molecule_type", "first_approval", "oral", "parenteral", "topical", "black_box_warning", "natural_product", "first_in_class", "chirality", "prodrug", "inorganic_flag", "usan_year", "availability_type", "usan_stem", "polymer_flag", "usan_substem", "usan_stem_definition", "indication_class", "withdrawn_flag", "withdrawn_year", "withdrawn_country", "withdrawn_reason", "withdrawn_class"}
	moleculeDictionaryColumnsWithoutDefault = []string{"molregno", "chembl_id", "max_phase", "therapeutic_flag", "dosed_ingredient", "structure_type", "oral", "parenteral", "topical", "black_box_warning", "natural_product", "first_in_class", "chirality", "prodrug", "inorganic_flag", "withdrawn_flag"}
	moleculeDictionaryColumnsWithDefault    = []string{"pref_name", "chebi_par_id", "molecule_type", "first_approval", "usan_year", "availability_type", "usan_stem", "polymer_flag", "usan_substem", "usan_stem_definition", "indication_class", "withdrawn_year", "withdrawn_country", "withdrawn_reason", "withdrawn_class"}
	moleculeDictionaryPrimaryKeyColumns     = []string{"molregno"}
	moleculeDictionaryGeneratedColumns      = []string{}
)

type (
	// MoleculeDictionarySlice is an alias for a slice of pointers to MoleculeDictionary.
	// This should almost always be used instead of []MoleculeDictionary.
	MoleculeDictionarySlice []*MoleculeDictionary
	// MoleculeDictionaryHook is the signature for custom MoleculeDictionary hook methods
	MoleculeDictionaryHook func(context.Context, boil.ContextExecutor, *MoleculeDictionary) error

	moleculeDictionaryQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	moleculeDictionaryType                 = reflect.TypeOf(&MoleculeDictionary{})
	moleculeDictionaryMapping              = queries.MakeStructMapping(moleculeDictionaryType)
	moleculeDictionaryPrimaryKeyMapping, _ = queries.BindMapping(moleculeDictionaryType, moleculeDictionaryMapping, moleculeDictionaryPrimaryKeyColumns)
	moleculeDictionaryInsertCacheMut       sync.RWMutex
	moleculeDictionaryInsertCache          = make(map[string]insertCache)
	moleculeDictionaryUpdateCacheMut       sync.RWMutex
	moleculeDictionaryUpdateCache          = make(map[string]updateCache)
	moleculeDictionaryUpsertCacheMut       sync.RWMutex
	moleculeDictionaryUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var moleculeDictionaryAfterSelectHooks []MoleculeDictionaryHook

var moleculeDictionaryBeforeInsertHooks []MoleculeDictionaryHook
var moleculeDictionaryAfterInsertHooks []MoleculeDictionaryHook

var moleculeDictionaryBeforeUpdateHooks []MoleculeDictionaryHook
var moleculeDictionaryAfterUpdateHooks []MoleculeDictionaryHook

var moleculeDictionaryBeforeDeleteHooks []MoleculeDictionaryHook
var moleculeDictionaryAfterDeleteHooks []MoleculeDictionaryHook

var moleculeDictionaryBeforeUpsertHooks []MoleculeDictionaryHook
var moleculeDictionaryAfterUpsertHooks []MoleculeDictionaryHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *MoleculeDictionary) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range moleculeDictionaryAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *MoleculeDictionary) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range moleculeDictionaryBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *MoleculeDictionary) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range moleculeDictionaryAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *MoleculeDictionary) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range moleculeDictionaryBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *MoleculeDictionary) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range moleculeDictionaryAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *MoleculeDictionary) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range moleculeDictionaryBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *MoleculeDictionary) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range moleculeDictionaryAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *MoleculeDictionary) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range moleculeDictionaryBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *MoleculeDictionary) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range moleculeDictionaryAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddMoleculeDictionaryHook registers your hook function for all future operations.
func AddMoleculeDictionaryHook(hookPoint boil.HookPoint, moleculeDictionaryHook MoleculeDictionaryHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		moleculeDictionaryAfterSelectHooks = append(moleculeDictionaryAfterSelectHooks, moleculeDictionaryHook)
	case boil.BeforeInsertHook:
		moleculeDictionaryBeforeInsertHooks = append(moleculeDictionaryBeforeInsertHooks, moleculeDictionaryHook)
	case boil.AfterInsertHook:
		moleculeDictionaryAfterInsertHooks = append(moleculeDictionaryAfterInsertHooks, moleculeDictionaryHook)
	case boil.BeforeUpdateHook:
		moleculeDictionaryBeforeUpdateHooks = append(moleculeDictionaryBeforeUpdateHooks, moleculeDictionaryHook)
	case boil.AfterUpdateHook:
		moleculeDictionaryAfterUpdateHooks = append(moleculeDictionaryAfterUpdateHooks, moleculeDictionaryHook)
	case boil.BeforeDeleteHook:
		moleculeDictionaryBeforeDeleteHooks = append(moleculeDictionaryBeforeDeleteHooks, moleculeDictionaryHook)
	case boil.AfterDeleteHook:
		moleculeDictionaryAfterDeleteHooks = append(moleculeDictionaryAfterDeleteHooks, moleculeDictionaryHook)
	case boil.BeforeUpsertHook:
		moleculeDictionaryBeforeUpsertHooks = append(moleculeDictionaryBeforeUpsertHooks, moleculeDictionaryHook)
	case boil.AfterUpsertHook:
		moleculeDictionaryAfterUpsertHooks = append(moleculeDictionaryAfterUpsertHooks, moleculeDictionaryHook)
	}
}

// One returns a single moleculeDictionary record from the query.
func (q moleculeDictionaryQuery) One(ctx context.Context, exec boil.ContextExecutor) (*MoleculeDictionary, error) {
	o := &MoleculeDictionary{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for molecule_dictionary")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all MoleculeDictionary records from the query.
func (q moleculeDictionaryQuery) All(ctx context.Context, exec boil.ContextExecutor) (MoleculeDictionarySlice, error) {
	var o []*MoleculeDictionary

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to MoleculeDictionary slice")
	}

	if len(moleculeDictionaryAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all MoleculeDictionary records in the query.
func (q moleculeDictionaryQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count molecule_dictionary rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q moleculeDictionaryQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if molecule_dictionary exists")
	}

	return count > 0, nil
}

// Chembl pointed to by the foreign key.
func (o *MoleculeDictionary) Chembl(mods ...qm.QueryMod) chemblIDLookupQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"chembl_id\" = ?", o.ChemblID),
	}

	queryMods = append(queryMods, mods...)

	return ChemblIDLookups(queryMods...)
}

// MolregnoBiotherapeutic pointed to by the foreign key.
func (o *MoleculeDictionary) MolregnoBiotherapeutic(mods ...qm.QueryMod) biotherapeuticQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"molregno\" = ?", o.Molregno),
	}

	queryMods = append(queryMods, mods...)

	return Biotherapeutics(queryMods...)
}

// MolregnoCompoundProperty pointed to by the foreign key.
func (o *MoleculeDictionary) MolregnoCompoundProperty(mods ...qm.QueryMod) compoundPropertyQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"molregno\" = ?", o.Molregno),
	}

	queryMods = append(queryMods, mods...)

	return CompoundProperties(queryMods...)
}

// MolregnoCompoundStructure pointed to by the foreign key.
func (o *MoleculeDictionary) MolregnoCompoundStructure(mods ...qm.QueryMod) compoundStructureQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"molregno\" = ?", o.Molregno),
	}

	queryMods = append(queryMods, mods...)

	return CompoundStructures(queryMods...)
}

// MolregnoMoleculeHierarchy pointed to by the foreign key.
func (o *MoleculeDictionary) MolregnoMoleculeHierarchy(mods ...qm.QueryMod) moleculeHierarchyQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"molregno\" = ?", o.Molregno),
	}

	queryMods = append(queryMods, mods...)

	return MoleculeHierarchies(queryMods...)
}

// MolregnoActivities retrieves all the activity's Activities with an executor via molregno column.
func (o *MoleculeDictionary) MolregnoActivities(mods ...qm.QueryMod) activityQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"activities\".\"molregno\"=?", o.Molregno),
	)

	return Activities(queryMods...)
}

// MolregnoCompoundRecords retrieves all the compound_record's CompoundRecords with an executor via molregno column.
func (o *MoleculeDictionary) MolregnoCompoundRecords(mods ...qm.QueryMod) compoundRecordQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"compound_records\".\"molregno\"=?", o.Molregno),
	)

	return CompoundRecords(queryMods...)
}

// MolregnoCompoundStructuralAlerts retrieves all the compound_structural_alert's CompoundStructuralAlerts with an executor via molregno column.
func (o *MoleculeDictionary) MolregnoCompoundStructuralAlerts(mods ...qm.QueryMod) compoundStructuralAlertQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"compound_structural_alerts\".\"molregno\"=?", o.Molregno),
	)

	return CompoundStructuralAlerts(queryMods...)
}

// MolregnoDrugIndications retrieves all the drug_indication's DrugIndications with an executor via molregno column.
func (o *MoleculeDictionary) MolregnoDrugIndications(mods ...qm.QueryMod) drugIndicationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"drug_indication\".\"molregno\"=?", o.Molregno),
	)

	return DrugIndications(queryMods...)
}

// MolregnoDrugMechanisms retrieves all the drug_mechanism's DrugMechanisms with an executor via molregno column.
func (o *MoleculeDictionary) MolregnoDrugMechanisms(mods ...qm.QueryMod) drugMechanismQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"drug_mechanism\".\"molregno\"=?", o.Molregno),
	)

	return DrugMechanisms(queryMods...)
}

// MolregnoFormulations retrieves all the formulation's Formulations with an executor via molregno column.
func (o *MoleculeDictionary) MolregnoFormulations(mods ...qm.QueryMod) formulationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"formulations\".\"molregno\"=?", o.Molregno),
	)

	return Formulations(queryMods...)
}

// MolregnoMoleculeAtcClassifications retrieves all the molecule_atc_classification's MoleculeAtcClassifications with an executor via molregno column.
func (o *MoleculeDictionary) MolregnoMoleculeAtcClassifications(mods ...qm.QueryMod) moleculeAtcClassificationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"molecule_atc_classification\".\"molregno\"=?", o.Molregno),
	)

	return MoleculeAtcClassifications(queryMods...)
}

// MolregnoMoleculeFracClassifications retrieves all the molecule_frac_classification's MoleculeFracClassifications with an executor via molregno column.
func (o *MoleculeDictionary) MolregnoMoleculeFracClassifications(mods ...qm.QueryMod) moleculeFracClassificationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"molecule_frac_classification\".\"molregno\"=?", o.Molregno),
	)

	return MoleculeFracClassifications(queryMods...)
}

// ParentMolregnoMoleculeHierarchies retrieves all the molecule_hierarchy's MoleculeHierarchies with an executor via parent_molregno column.
func (o *MoleculeDictionary) ParentMolregnoMoleculeHierarchies(mods ...qm.QueryMod) moleculeHierarchyQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"molecule_hierarchy\".\"parent_molregno\"=?", o.Molregno),
	)

	return MoleculeHierarchies(queryMods...)
}

// ActiveMolregnoMoleculeHierarchies retrieves all the molecule_hierarchy's MoleculeHierarchies with an executor via active_molregno column.
func (o *MoleculeDictionary) ActiveMolregnoMoleculeHierarchies(mods ...qm.QueryMod) moleculeHierarchyQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"molecule_hierarchy\".\"active_molregno\"=?", o.Molregno),
	)

	return MoleculeHierarchies(queryMods...)
}

// MolregnoMoleculeHracClassifications retrieves all the molecule_hrac_classification's MoleculeHracClassifications with an executor via molregno column.
func (o *MoleculeDictionary) MolregnoMoleculeHracClassifications(mods ...qm.QueryMod) moleculeHracClassificationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"molecule_hrac_classification\".\"molregno\"=?", o.Molregno),
	)

	return MoleculeHracClassifications(queryMods...)
}

// MolregnoMoleculeIracClassifications retrieves all the molecule_irac_classification's MoleculeIracClassifications with an executor via molregno column.
func (o *MoleculeDictionary) MolregnoMoleculeIracClassifications(mods ...qm.QueryMod) moleculeIracClassificationQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"molecule_irac_classification\".\"molregno\"=?", o.Molregno),
	)

	return MoleculeIracClassifications(queryMods...)
}

// MolregnoMoleculeSynonyms retrieves all the molecule_synonym's MoleculeSynonyms with an executor via molregno column.
func (o *MoleculeDictionary) MolregnoMoleculeSynonyms(mods ...qm.QueryMod) moleculeSynonymQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"molecule_synonyms\".\"molregno\"=?", o.Molregno),
	)

	return MoleculeSynonyms(queryMods...)
}

// LoadChembl allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (moleculeDictionaryL) LoadChembl(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.ChemblID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if a == obj.ChemblID {
					continue Outer
				}
			}

			args = append(args, obj.ChemblID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`chembl_id_lookup`),
		qm.WhereIn(`chembl_id_lookup.chembl_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load ChemblIDLookup")
	}

	var resultSlice []*ChemblIDLookup
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice ChemblIDLookup")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for chembl_id_lookup")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for chembl_id_lookup")
	}

	if len(moleculeDictionaryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Chembl = foreign
		if foreign.R == nil {
			foreign.R = &chemblIDLookupR{}
		}
		foreign.R.ChemblMoleculeDictionary = object
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ChemblID == foreign.ChemblID {
				local.R.Chembl = foreign
				if foreign.R == nil {
					foreign.R = &chemblIDLookupR{}
				}
				foreign.R.ChemblMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadMolregnoBiotherapeutic allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (moleculeDictionaryL) LoadMolregnoBiotherapeutic(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if a == obj.Molregno {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`biotherapeutics`),
		qm.WhereIn(`biotherapeutics.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Biotherapeutic")
	}

	var resultSlice []*Biotherapeutic
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Biotherapeutic")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for biotherapeutics")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for biotherapeutics")
	}

	if len(moleculeDictionaryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MolregnoBiotherapeutic = foreign
		if foreign.R == nil {
			foreign.R = &biotherapeuticR{}
		}
		foreign.R.MolregnoMoleculeDictionary = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Molregno == foreign.Molregno {
				local.R.MolregnoBiotherapeutic = foreign
				if foreign.R == nil {
					foreign.R = &biotherapeuticR{}
				}
				foreign.R.MolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadMolregnoCompoundProperty allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (moleculeDictionaryL) LoadMolregnoCompoundProperty(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if a == obj.Molregno {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`compound_properties`),
		qm.WhereIn(`compound_properties.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CompoundProperty")
	}

	var resultSlice []*CompoundProperty
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CompoundProperty")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for compound_properties")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for compound_properties")
	}

	if len(moleculeDictionaryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MolregnoCompoundProperty = foreign
		if foreign.R == nil {
			foreign.R = &compoundPropertyR{}
		}
		foreign.R.MolregnoMoleculeDictionary = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Molregno == foreign.Molregno {
				local.R.MolregnoCompoundProperty = foreign
				if foreign.R == nil {
					foreign.R = &compoundPropertyR{}
				}
				foreign.R.MolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadMolregnoCompoundStructure allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (moleculeDictionaryL) LoadMolregnoCompoundStructure(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if a == obj.Molregno {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`compound_structures`),
		qm.WhereIn(`compound_structures.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CompoundStructure")
	}

	var resultSlice []*CompoundStructure
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CompoundStructure")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for compound_structures")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for compound_structures")
	}

	if len(moleculeDictionaryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MolregnoCompoundStructure = foreign
		if foreign.R == nil {
			foreign.R = &compoundStructureR{}
		}
		foreign.R.MolregnoMoleculeDictionary = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Molregno == foreign.Molregno {
				local.R.MolregnoCompoundStructure = foreign
				if foreign.R == nil {
					foreign.R = &compoundStructureR{}
				}
				foreign.R.MolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadMolregnoMoleculeHierarchy allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (moleculeDictionaryL) LoadMolregnoMoleculeHierarchy(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if a == obj.Molregno {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`molecule_hierarchy`),
		qm.WhereIn(`molecule_hierarchy.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MoleculeHierarchy")
	}

	var resultSlice []*MoleculeHierarchy
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MoleculeHierarchy")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for molecule_hierarchy")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for molecule_hierarchy")
	}

	if len(moleculeDictionaryAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MolregnoMoleculeHierarchy = foreign
		if foreign.R == nil {
			foreign.R = &moleculeHierarchyR{}
		}
		foreign.R.MolregnoMoleculeDictionary = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Molregno == foreign.Molregno {
				local.R.MolregnoMoleculeHierarchy = foreign
				if foreign.R == nil {
					foreign.R = &moleculeHierarchyR{}
				}
				foreign.R.MolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadMolregnoActivities allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (moleculeDictionaryL) LoadMolregnoActivities(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Molregno) {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`activities`),
		qm.WhereIn(`activities.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load activities")
	}

	var resultSlice []*Activity
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice activities")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on activities")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for activities")
	}

	if len(activityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MolregnoActivities = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &activityR{}
			}
			foreign.R.MolregnoMoleculeDictionary = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.Molregno, foreign.Molregno) {
				local.R.MolregnoActivities = append(local.R.MolregnoActivities, foreign)
				if foreign.R == nil {
					foreign.R = &activityR{}
				}
				foreign.R.MolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadMolregnoCompoundRecords allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (moleculeDictionaryL) LoadMolregnoCompoundRecords(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Molregno) {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`compound_records`),
		qm.WhereIn(`compound_records.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load compound_records")
	}

	var resultSlice []*CompoundRecord
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice compound_records")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on compound_records")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for compound_records")
	}

	if len(compoundRecordAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MolregnoCompoundRecords = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &compoundRecordR{}
			}
			foreign.R.MolregnoMoleculeDictionary = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.Molregno, foreign.Molregno) {
				local.R.MolregnoCompoundRecords = append(local.R.MolregnoCompoundRecords, foreign)
				if foreign.R == nil {
					foreign.R = &compoundRecordR{}
				}
				foreign.R.MolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadMolregnoCompoundStructuralAlerts allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (moleculeDictionaryL) LoadMolregnoCompoundStructuralAlerts(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if a == obj.Molregno {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`compound_structural_alerts`),
		qm.WhereIn(`compound_structural_alerts.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load compound_structural_alerts")
	}

	var resultSlice []*CompoundStructuralAlert
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice compound_structural_alerts")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on compound_structural_alerts")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for compound_structural_alerts")
	}

	if len(compoundStructuralAlertAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MolregnoCompoundStructuralAlerts = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &compoundStructuralAlertR{}
			}
			foreign.R.MolregnoMoleculeDictionary = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Molregno == foreign.Molregno {
				local.R.MolregnoCompoundStructuralAlerts = append(local.R.MolregnoCompoundStructuralAlerts, foreign)
				if foreign.R == nil {
					foreign.R = &compoundStructuralAlertR{}
				}
				foreign.R.MolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadMolregnoDrugIndications allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (moleculeDictionaryL) LoadMolregnoDrugIndications(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Molregno) {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`drug_indication`),
		qm.WhereIn(`drug_indication.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load drug_indication")
	}

	var resultSlice []*DrugIndication
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice drug_indication")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on drug_indication")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for drug_indication")
	}

	if len(drugIndicationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MolregnoDrugIndications = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &drugIndicationR{}
			}
			foreign.R.MolregnoMoleculeDictionary = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.Molregno, foreign.Molregno) {
				local.R.MolregnoDrugIndications = append(local.R.MolregnoDrugIndications, foreign)
				if foreign.R == nil {
					foreign.R = &drugIndicationR{}
				}
				foreign.R.MolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadMolregnoDrugMechanisms allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (moleculeDictionaryL) LoadMolregnoDrugMechanisms(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Molregno) {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`drug_mechanism`),
		qm.WhereIn(`drug_mechanism.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load drug_mechanism")
	}

	var resultSlice []*DrugMechanism
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice drug_mechanism")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on drug_mechanism")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for drug_mechanism")
	}

	if len(drugMechanismAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MolregnoDrugMechanisms = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &drugMechanismR{}
			}
			foreign.R.MolregnoMoleculeDictionary = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.Molregno, foreign.Molregno) {
				local.R.MolregnoDrugMechanisms = append(local.R.MolregnoDrugMechanisms, foreign)
				if foreign.R == nil {
					foreign.R = &drugMechanismR{}
				}
				foreign.R.MolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadMolregnoFormulations allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (moleculeDictionaryL) LoadMolregnoFormulations(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Molregno) {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`formulations`),
		qm.WhereIn(`formulations.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load formulations")
	}

	var resultSlice []*Formulation
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice formulations")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on formulations")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for formulations")
	}

	if len(formulationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MolregnoFormulations = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &formulationR{}
			}
			foreign.R.MolregnoMoleculeDictionary = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.Molregno, foreign.Molregno) {
				local.R.MolregnoFormulations = append(local.R.MolregnoFormulations, foreign)
				if foreign.R == nil {
					foreign.R = &formulationR{}
				}
				foreign.R.MolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadMolregnoMoleculeAtcClassifications allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (moleculeDictionaryL) LoadMolregnoMoleculeAtcClassifications(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if a == obj.Molregno {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`molecule_atc_classification`),
		qm.WhereIn(`molecule_atc_classification.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load molecule_atc_classification")
	}

	var resultSlice []*MoleculeAtcClassification
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice molecule_atc_classification")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on molecule_atc_classification")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for molecule_atc_classification")
	}

	if len(moleculeAtcClassificationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MolregnoMoleculeAtcClassifications = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &moleculeAtcClassificationR{}
			}
			foreign.R.MolregnoMoleculeDictionary = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Molregno == foreign.Molregno {
				local.R.MolregnoMoleculeAtcClassifications = append(local.R.MolregnoMoleculeAtcClassifications, foreign)
				if foreign.R == nil {
					foreign.R = &moleculeAtcClassificationR{}
				}
				foreign.R.MolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadMolregnoMoleculeFracClassifications allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (moleculeDictionaryL) LoadMolregnoMoleculeFracClassifications(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if a == obj.Molregno {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`molecule_frac_classification`),
		qm.WhereIn(`molecule_frac_classification.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load molecule_frac_classification")
	}

	var resultSlice []*MoleculeFracClassification
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice molecule_frac_classification")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on molecule_frac_classification")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for molecule_frac_classification")
	}

	if len(moleculeFracClassificationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MolregnoMoleculeFracClassifications = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &moleculeFracClassificationR{}
			}
			foreign.R.MolregnoMoleculeDictionary = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Molregno == foreign.Molregno {
				local.R.MolregnoMoleculeFracClassifications = append(local.R.MolregnoMoleculeFracClassifications, foreign)
				if foreign.R == nil {
					foreign.R = &moleculeFracClassificationR{}
				}
				foreign.R.MolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadParentMolregnoMoleculeHierarchies allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (moleculeDictionaryL) LoadParentMolregnoMoleculeHierarchies(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Molregno) {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`molecule_hierarchy`),
		qm.WhereIn(`molecule_hierarchy.parent_molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load molecule_hierarchy")
	}

	var resultSlice []*MoleculeHierarchy
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice molecule_hierarchy")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on molecule_hierarchy")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for molecule_hierarchy")
	}

	if len(moleculeHierarchyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ParentMolregnoMoleculeHierarchies = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &moleculeHierarchyR{}
			}
			foreign.R.ParentMolregnoMoleculeDictionary = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.Molregno, foreign.ParentMolregno) {
				local.R.ParentMolregnoMoleculeHierarchies = append(local.R.ParentMolregnoMoleculeHierarchies, foreign)
				if foreign.R == nil {
					foreign.R = &moleculeHierarchyR{}
				}
				foreign.R.ParentMolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadActiveMolregnoMoleculeHierarchies allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (moleculeDictionaryL) LoadActiveMolregnoMoleculeHierarchies(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Molregno) {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`molecule_hierarchy`),
		qm.WhereIn(`molecule_hierarchy.active_molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load molecule_hierarchy")
	}

	var resultSlice []*MoleculeHierarchy
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice molecule_hierarchy")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on molecule_hierarchy")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for molecule_hierarchy")
	}

	if len(moleculeHierarchyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ActiveMolregnoMoleculeHierarchies = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &moleculeHierarchyR{}
			}
			foreign.R.ActiveMolregnoMoleculeDictionary = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.Molregno, foreign.ActiveMolregno) {
				local.R.ActiveMolregnoMoleculeHierarchies = append(local.R.ActiveMolregnoMoleculeHierarchies, foreign)
				if foreign.R == nil {
					foreign.R = &moleculeHierarchyR{}
				}
				foreign.R.ActiveMolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadMolregnoMoleculeHracClassifications allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (moleculeDictionaryL) LoadMolregnoMoleculeHracClassifications(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if a == obj.Molregno {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`molecule_hrac_classification`),
		qm.WhereIn(`molecule_hrac_classification.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load molecule_hrac_classification")
	}

	var resultSlice []*MoleculeHracClassification
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice molecule_hrac_classification")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on molecule_hrac_classification")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for molecule_hrac_classification")
	}

	if len(moleculeHracClassificationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MolregnoMoleculeHracClassifications = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &moleculeHracClassificationR{}
			}
			foreign.R.MolregnoMoleculeDictionary = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Molregno == foreign.Molregno {
				local.R.MolregnoMoleculeHracClassifications = append(local.R.MolregnoMoleculeHracClassifications, foreign)
				if foreign.R == nil {
					foreign.R = &moleculeHracClassificationR{}
				}
				foreign.R.MolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadMolregnoMoleculeIracClassifications allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (moleculeDictionaryL) LoadMolregnoMoleculeIracClassifications(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if a == obj.Molregno {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`molecule_irac_classification`),
		qm.WhereIn(`molecule_irac_classification.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load molecule_irac_classification")
	}

	var resultSlice []*MoleculeIracClassification
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice molecule_irac_classification")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on molecule_irac_classification")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for molecule_irac_classification")
	}

	if len(moleculeIracClassificationAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MolregnoMoleculeIracClassifications = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &moleculeIracClassificationR{}
			}
			foreign.R.MolregnoMoleculeDictionary = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Molregno == foreign.Molregno {
				local.R.MolregnoMoleculeIracClassifications = append(local.R.MolregnoMoleculeIracClassifications, foreign)
				if foreign.R == nil {
					foreign.R = &moleculeIracClassificationR{}
				}
				foreign.R.MolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// LoadMolregnoMoleculeSynonyms allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (moleculeDictionaryL) LoadMolregnoMoleculeSynonyms(ctx context.Context, e boil.ContextExecutor, singular bool, maybeMoleculeDictionary interface{}, mods queries.Applicator) error {
	var slice []*MoleculeDictionary
	var object *MoleculeDictionary

	if singular {
		object = maybeMoleculeDictionary.(*MoleculeDictionary)
	} else {
		slice = *maybeMoleculeDictionary.(*[]*MoleculeDictionary)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &moleculeDictionaryR{}
		}
		args = append(args, object.Molregno)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &moleculeDictionaryR{}
			}

			for _, a := range args {
				if a == obj.Molregno {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`molecule_synonyms`),
		qm.WhereIn(`molecule_synonyms.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load molecule_synonyms")
	}

	var resultSlice []*MoleculeSynonym
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice molecule_synonyms")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on molecule_synonyms")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for molecule_synonyms")
	}

	if len(moleculeSynonymAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.MolregnoMoleculeSynonyms = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &moleculeSynonymR{}
			}
			foreign.R.MolregnoMoleculeDictionary = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.Molregno == foreign.Molregno {
				local.R.MolregnoMoleculeSynonyms = append(local.R.MolregnoMoleculeSynonyms, foreign)
				if foreign.R == nil {
					foreign.R = &moleculeSynonymR{}
				}
				foreign.R.MolregnoMoleculeDictionary = local
				break
			}
		}
	}

	return nil
}

// SetChembl of the moleculeDictionary to the related item.
// Sets o.R.Chembl to related.
// Adds o to related.R.ChemblMoleculeDictionary.
func (o *MoleculeDictionary) SetChembl(ctx context.Context, exec boil.ContextExecutor, insert bool, related *ChemblIDLookup) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"molecule_dictionary\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"chembl_id"}),
		strmangle.WhereClause("\"", "\"", 0, moleculeDictionaryPrimaryKeyColumns),
	)
	values := []interface{}{related.ChemblID, o.Molregno}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ChemblID = related.ChemblID
	if o.R == nil {
		o.R = &moleculeDictionaryR{
			Chembl: related,
		}
	} else {
		o.R.Chembl = related
	}

	if related.R == nil {
		related.R = &chemblIDLookupR{
			ChemblMoleculeDictionary: o,
		}
	} else {
		related.R.ChemblMoleculeDictionary = o
	}

	return nil
}

// SetMolregnoBiotherapeutic of the moleculeDictionary to the related item.
// Sets o.R.MolregnoBiotherapeutic to related.
// Adds o to related.R.MolregnoMoleculeDictionary.
func (o *MoleculeDictionary) SetMolregnoBiotherapeutic(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Biotherapeutic) error {
	var err error

	if insert {
		related.Molregno = o.Molregno

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"biotherapeutics\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
			strmangle.WhereClause("\"", "\"", 0, biotherapeuticPrimaryKeyColumns),
		)
		values := []interface{}{o.Molregno, related.Molregno}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.Molregno = o.Molregno
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			MolregnoBiotherapeutic: related,
		}
	} else {
		o.R.MolregnoBiotherapeutic = related
	}

	if related.R == nil {
		related.R = &biotherapeuticR{
			MolregnoMoleculeDictionary: o,
		}
	} else {
		related.R.MolregnoMoleculeDictionary = o
	}
	return nil
}

// SetMolregnoCompoundProperty of the moleculeDictionary to the related item.
// Sets o.R.MolregnoCompoundProperty to related.
// Adds o to related.R.MolregnoMoleculeDictionary.
func (o *MoleculeDictionary) SetMolregnoCompoundProperty(ctx context.Context, exec boil.ContextExecutor, insert bool, related *CompoundProperty) error {
	var err error

	if insert {
		related.Molregno = o.Molregno

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"compound_properties\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
			strmangle.WhereClause("\"", "\"", 0, compoundPropertyPrimaryKeyColumns),
		)
		values := []interface{}{o.Molregno, related.Molregno}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.Molregno = o.Molregno
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			MolregnoCompoundProperty: related,
		}
	} else {
		o.R.MolregnoCompoundProperty = related
	}

	if related.R == nil {
		related.R = &compoundPropertyR{
			MolregnoMoleculeDictionary: o,
		}
	} else {
		related.R.MolregnoMoleculeDictionary = o
	}
	return nil
}

// SetMolregnoCompoundStructure of the moleculeDictionary to the related item.
// Sets o.R.MolregnoCompoundStructure to related.
// Adds o to related.R.MolregnoMoleculeDictionary.
func (o *MoleculeDictionary) SetMolregnoCompoundStructure(ctx context.Context, exec boil.ContextExecutor, insert bool, related *CompoundStructure) error {
	var err error

	if insert {
		related.Molregno = o.Molregno

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"compound_structures\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
			strmangle.WhereClause("\"", "\"", 0, compoundStructurePrimaryKeyColumns),
		)
		values := []interface{}{o.Molregno, related.Molregno}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.Molregno = o.Molregno
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			MolregnoCompoundStructure: related,
		}
	} else {
		o.R.MolregnoCompoundStructure = related
	}

	if related.R == nil {
		related.R = &compoundStructureR{
			MolregnoMoleculeDictionary: o,
		}
	} else {
		related.R.MolregnoMoleculeDictionary = o
	}
	return nil
}

// SetMolregnoMoleculeHierarchy of the moleculeDictionary to the related item.
// Sets o.R.MolregnoMoleculeHierarchy to related.
// Adds o to related.R.MolregnoMoleculeDictionary.
func (o *MoleculeDictionary) SetMolregnoMoleculeHierarchy(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MoleculeHierarchy) error {
	var err error

	if insert {
		related.Molregno = o.Molregno

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"molecule_hierarchy\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
			strmangle.WhereClause("\"", "\"", 0, moleculeHierarchyPrimaryKeyColumns),
		)
		values := []interface{}{o.Molregno, related.Molregno}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.Molregno = o.Molregno
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			MolregnoMoleculeHierarchy: related,
		}
	} else {
		o.R.MolregnoMoleculeHierarchy = related
	}

	if related.R == nil {
		related.R = &moleculeHierarchyR{
			MolregnoMoleculeDictionary: o,
		}
	} else {
		related.R.MolregnoMoleculeDictionary = o
	}
	return nil
}

// AddMolregnoActivities adds the given related objects to the existing relationships
// of the molecule_dictionary, optionally inserting them as new records.
// Appends related to o.R.MolregnoActivities.
// Sets related.R.MolregnoMoleculeDictionary appropriately.
func (o *MoleculeDictionary) AddMolregnoActivities(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Activity) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Molregno, o.Molregno)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"activities\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
				strmangle.WhereClause("\"", "\"", 0, activityPrimaryKeyColumns),
			)
			values := []interface{}{o.Molregno, rel.ActivityID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Molregno, o.Molregno)
		}
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			MolregnoActivities: related,
		}
	} else {
		o.R.MolregnoActivities = append(o.R.MolregnoActivities, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &activityR{
				MolregnoMoleculeDictionary: o,
			}
		} else {
			rel.R.MolregnoMoleculeDictionary = o
		}
	}
	return nil
}

// SetMolregnoActivities removes all previously related items of the
// molecule_dictionary replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.MolregnoMoleculeDictionary's MolregnoActivities accordingly.
// Replaces o.R.MolregnoActivities with related.
// Sets related.R.MolregnoMoleculeDictionary's MolregnoActivities accordingly.
func (o *MoleculeDictionary) SetMolregnoActivities(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Activity) error {
	query := "update \"activities\" set \"molregno\" = null where \"molregno\" = ?"
	values := []interface{}{o.Molregno}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.MolregnoActivities {
			queries.SetScanner(&rel.Molregno, nil)
			if rel.R == nil {
				continue
			}

			rel.R.MolregnoMoleculeDictionary = nil
		}
		o.R.MolregnoActivities = nil
	}

	return o.AddMolregnoActivities(ctx, exec, insert, related...)
}

// RemoveMolregnoActivities relationships from objects passed in.
// Removes related items from R.MolregnoActivities (uses pointer comparison, removal does not keep order)
// Sets related.R.MolregnoMoleculeDictionary.
func (o *MoleculeDictionary) RemoveMolregnoActivities(ctx context.Context, exec boil.ContextExecutor, related ...*Activity) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Molregno, nil)
		if rel.R != nil {
			rel.R.MolregnoMoleculeDictionary = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("molregno")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MolregnoActivities {
			if rel != ri {
				continue
			}

			ln := len(o.R.MolregnoActivities)
			if ln > 1 && i < ln-1 {
				o.R.MolregnoActivities[i] = o.R.MolregnoActivities[ln-1]
			}
			o.R.MolregnoActivities = o.R.MolregnoActivities[:ln-1]
			break
		}
	}

	return nil
}

// AddMolregnoCompoundRecords adds the given related objects to the existing relationships
// of the molecule_dictionary, optionally inserting them as new records.
// Appends related to o.R.MolregnoCompoundRecords.
// Sets related.R.MolregnoMoleculeDictionary appropriately.
func (o *MoleculeDictionary) AddMolregnoCompoundRecords(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CompoundRecord) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Molregno, o.Molregno)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"compound_records\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
				strmangle.WhereClause("\"", "\"", 0, compoundRecordPrimaryKeyColumns),
			)
			values := []interface{}{o.Molregno, rel.RecordID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Molregno, o.Molregno)
		}
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			MolregnoCompoundRecords: related,
		}
	} else {
		o.R.MolregnoCompoundRecords = append(o.R.MolregnoCompoundRecords, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &compoundRecordR{
				MolregnoMoleculeDictionary: o,
			}
		} else {
			rel.R.MolregnoMoleculeDictionary = o
		}
	}
	return nil
}

// SetMolregnoCompoundRecords removes all previously related items of the
// molecule_dictionary replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.MolregnoMoleculeDictionary's MolregnoCompoundRecords accordingly.
// Replaces o.R.MolregnoCompoundRecords with related.
// Sets related.R.MolregnoMoleculeDictionary's MolregnoCompoundRecords accordingly.
func (o *MoleculeDictionary) SetMolregnoCompoundRecords(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CompoundRecord) error {
	query := "update \"compound_records\" set \"molregno\" = null where \"molregno\" = ?"
	values := []interface{}{o.Molregno}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.MolregnoCompoundRecords {
			queries.SetScanner(&rel.Molregno, nil)
			if rel.R == nil {
				continue
			}

			rel.R.MolregnoMoleculeDictionary = nil
		}
		o.R.MolregnoCompoundRecords = nil
	}

	return o.AddMolregnoCompoundRecords(ctx, exec, insert, related...)
}

// RemoveMolregnoCompoundRecords relationships from objects passed in.
// Removes related items from R.MolregnoCompoundRecords (uses pointer comparison, removal does not keep order)
// Sets related.R.MolregnoMoleculeDictionary.
func (o *MoleculeDictionary) RemoveMolregnoCompoundRecords(ctx context.Context, exec boil.ContextExecutor, related ...*CompoundRecord) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Molregno, nil)
		if rel.R != nil {
			rel.R.MolregnoMoleculeDictionary = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("molregno")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MolregnoCompoundRecords {
			if rel != ri {
				continue
			}

			ln := len(o.R.MolregnoCompoundRecords)
			if ln > 1 && i < ln-1 {
				o.R.MolregnoCompoundRecords[i] = o.R.MolregnoCompoundRecords[ln-1]
			}
			o.R.MolregnoCompoundRecords = o.R.MolregnoCompoundRecords[:ln-1]
			break
		}
	}

	return nil
}

// AddMolregnoCompoundStructuralAlerts adds the given related objects to the existing relationships
// of the molecule_dictionary, optionally inserting them as new records.
// Appends related to o.R.MolregnoCompoundStructuralAlerts.
// Sets related.R.MolregnoMoleculeDictionary appropriately.
func (o *MoleculeDictionary) AddMolregnoCompoundStructuralAlerts(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*CompoundStructuralAlert) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Molregno = o.Molregno
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"compound_structural_alerts\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
				strmangle.WhereClause("\"", "\"", 0, compoundStructuralAlertPrimaryKeyColumns),
			)
			values := []interface{}{o.Molregno, rel.CPDSTRAlertID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Molregno = o.Molregno
		}
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			MolregnoCompoundStructuralAlerts: related,
		}
	} else {
		o.R.MolregnoCompoundStructuralAlerts = append(o.R.MolregnoCompoundStructuralAlerts, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &compoundStructuralAlertR{
				MolregnoMoleculeDictionary: o,
			}
		} else {
			rel.R.MolregnoMoleculeDictionary = o
		}
	}
	return nil
}

// AddMolregnoDrugIndications adds the given related objects to the existing relationships
// of the molecule_dictionary, optionally inserting them as new records.
// Appends related to o.R.MolregnoDrugIndications.
// Sets related.R.MolregnoMoleculeDictionary appropriately.
func (o *MoleculeDictionary) AddMolregnoDrugIndications(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DrugIndication) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Molregno, o.Molregno)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"drug_indication\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
				strmangle.WhereClause("\"", "\"", 0, drugIndicationPrimaryKeyColumns),
			)
			values := []interface{}{o.Molregno, rel.DrugindID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Molregno, o.Molregno)
		}
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			MolregnoDrugIndications: related,
		}
	} else {
		o.R.MolregnoDrugIndications = append(o.R.MolregnoDrugIndications, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &drugIndicationR{
				MolregnoMoleculeDictionary: o,
			}
		} else {
			rel.R.MolregnoMoleculeDictionary = o
		}
	}
	return nil
}

// SetMolregnoDrugIndications removes all previously related items of the
// molecule_dictionary replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.MolregnoMoleculeDictionary's MolregnoDrugIndications accordingly.
// Replaces o.R.MolregnoDrugIndications with related.
// Sets related.R.MolregnoMoleculeDictionary's MolregnoDrugIndications accordingly.
func (o *MoleculeDictionary) SetMolregnoDrugIndications(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DrugIndication) error {
	query := "update \"drug_indication\" set \"molregno\" = null where \"molregno\" = ?"
	values := []interface{}{o.Molregno}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.MolregnoDrugIndications {
			queries.SetScanner(&rel.Molregno, nil)
			if rel.R == nil {
				continue
			}

			rel.R.MolregnoMoleculeDictionary = nil
		}
		o.R.MolregnoDrugIndications = nil
	}

	return o.AddMolregnoDrugIndications(ctx, exec, insert, related...)
}

// RemoveMolregnoDrugIndications relationships from objects passed in.
// Removes related items from R.MolregnoDrugIndications (uses pointer comparison, removal does not keep order)
// Sets related.R.MolregnoMoleculeDictionary.
func (o *MoleculeDictionary) RemoveMolregnoDrugIndications(ctx context.Context, exec boil.ContextExecutor, related ...*DrugIndication) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Molregno, nil)
		if rel.R != nil {
			rel.R.MolregnoMoleculeDictionary = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("molregno")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MolregnoDrugIndications {
			if rel != ri {
				continue
			}

			ln := len(o.R.MolregnoDrugIndications)
			if ln > 1 && i < ln-1 {
				o.R.MolregnoDrugIndications[i] = o.R.MolregnoDrugIndications[ln-1]
			}
			o.R.MolregnoDrugIndications = o.R.MolregnoDrugIndications[:ln-1]
			break
		}
	}

	return nil
}

// AddMolregnoDrugMechanisms adds the given related objects to the existing relationships
// of the molecule_dictionary, optionally inserting them as new records.
// Appends related to o.R.MolregnoDrugMechanisms.
// Sets related.R.MolregnoMoleculeDictionary appropriately.
func (o *MoleculeDictionary) AddMolregnoDrugMechanisms(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DrugMechanism) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Molregno, o.Molregno)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"drug_mechanism\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
				strmangle.WhereClause("\"", "\"", 0, drugMechanismPrimaryKeyColumns),
			)
			values := []interface{}{o.Molregno, rel.MecID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Molregno, o.Molregno)
		}
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			MolregnoDrugMechanisms: related,
		}
	} else {
		o.R.MolregnoDrugMechanisms = append(o.R.MolregnoDrugMechanisms, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &drugMechanismR{
				MolregnoMoleculeDictionary: o,
			}
		} else {
			rel.R.MolregnoMoleculeDictionary = o
		}
	}
	return nil
}

// SetMolregnoDrugMechanisms removes all previously related items of the
// molecule_dictionary replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.MolregnoMoleculeDictionary's MolregnoDrugMechanisms accordingly.
// Replaces o.R.MolregnoDrugMechanisms with related.
// Sets related.R.MolregnoMoleculeDictionary's MolregnoDrugMechanisms accordingly.
func (o *MoleculeDictionary) SetMolregnoDrugMechanisms(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DrugMechanism) error {
	query := "update \"drug_mechanism\" set \"molregno\" = null where \"molregno\" = ?"
	values := []interface{}{o.Molregno}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.MolregnoDrugMechanisms {
			queries.SetScanner(&rel.Molregno, nil)
			if rel.R == nil {
				continue
			}

			rel.R.MolregnoMoleculeDictionary = nil
		}
		o.R.MolregnoDrugMechanisms = nil
	}

	return o.AddMolregnoDrugMechanisms(ctx, exec, insert, related...)
}

// RemoveMolregnoDrugMechanisms relationships from objects passed in.
// Removes related items from R.MolregnoDrugMechanisms (uses pointer comparison, removal does not keep order)
// Sets related.R.MolregnoMoleculeDictionary.
func (o *MoleculeDictionary) RemoveMolregnoDrugMechanisms(ctx context.Context, exec boil.ContextExecutor, related ...*DrugMechanism) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Molregno, nil)
		if rel.R != nil {
			rel.R.MolregnoMoleculeDictionary = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("molregno")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MolregnoDrugMechanisms {
			if rel != ri {
				continue
			}

			ln := len(o.R.MolregnoDrugMechanisms)
			if ln > 1 && i < ln-1 {
				o.R.MolregnoDrugMechanisms[i] = o.R.MolregnoDrugMechanisms[ln-1]
			}
			o.R.MolregnoDrugMechanisms = o.R.MolregnoDrugMechanisms[:ln-1]
			break
		}
	}

	return nil
}

// AddMolregnoFormulations adds the given related objects to the existing relationships
// of the molecule_dictionary, optionally inserting them as new records.
// Appends related to o.R.MolregnoFormulations.
// Sets related.R.MolregnoMoleculeDictionary appropriately.
func (o *MoleculeDictionary) AddMolregnoFormulations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Formulation) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.Molregno, o.Molregno)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"formulations\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
				strmangle.WhereClause("\"", "\"", 0, formulationPrimaryKeyColumns),
			)
			values := []interface{}{o.Molregno, rel.FormulationID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.Molregno, o.Molregno)
		}
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			MolregnoFormulations: related,
		}
	} else {
		o.R.MolregnoFormulations = append(o.R.MolregnoFormulations, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &formulationR{
				MolregnoMoleculeDictionary: o,
			}
		} else {
			rel.R.MolregnoMoleculeDictionary = o
		}
	}
	return nil
}

// SetMolregnoFormulations removes all previously related items of the
// molecule_dictionary replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.MolregnoMoleculeDictionary's MolregnoFormulations accordingly.
// Replaces o.R.MolregnoFormulations with related.
// Sets related.R.MolregnoMoleculeDictionary's MolregnoFormulations accordingly.
func (o *MoleculeDictionary) SetMolregnoFormulations(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Formulation) error {
	query := "update \"formulations\" set \"molregno\" = null where \"molregno\" = ?"
	values := []interface{}{o.Molregno}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.MolregnoFormulations {
			queries.SetScanner(&rel.Molregno, nil)
			if rel.R == nil {
				continue
			}

			rel.R.MolregnoMoleculeDictionary = nil
		}
		o.R.MolregnoFormulations = nil
	}

	return o.AddMolregnoFormulations(ctx, exec, insert, related...)
}

// RemoveMolregnoFormulations relationships from objects passed in.
// Removes related items from R.MolregnoFormulations (uses pointer comparison, removal does not keep order)
// Sets related.R.MolregnoMoleculeDictionary.
func (o *MoleculeDictionary) RemoveMolregnoFormulations(ctx context.Context, exec boil.ContextExecutor, related ...*Formulation) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.Molregno, nil)
		if rel.R != nil {
			rel.R.MolregnoMoleculeDictionary = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("molregno")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.MolregnoFormulations {
			if rel != ri {
				continue
			}

			ln := len(o.R.MolregnoFormulations)
			if ln > 1 && i < ln-1 {
				o.R.MolregnoFormulations[i] = o.R.MolregnoFormulations[ln-1]
			}
			o.R.MolregnoFormulations = o.R.MolregnoFormulations[:ln-1]
			break
		}
	}

	return nil
}

// AddMolregnoMoleculeAtcClassifications adds the given related objects to the existing relationships
// of the molecule_dictionary, optionally inserting them as new records.
// Appends related to o.R.MolregnoMoleculeAtcClassifications.
// Sets related.R.MolregnoMoleculeDictionary appropriately.
func (o *MoleculeDictionary) AddMolregnoMoleculeAtcClassifications(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MoleculeAtcClassification) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Molregno = o.Molregno
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"molecule_atc_classification\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
				strmangle.WhereClause("\"", "\"", 0, moleculeAtcClassificationPrimaryKeyColumns),
			)
			values := []interface{}{o.Molregno, rel.MolAtcID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Molregno = o.Molregno
		}
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			MolregnoMoleculeAtcClassifications: related,
		}
	} else {
		o.R.MolregnoMoleculeAtcClassifications = append(o.R.MolregnoMoleculeAtcClassifications, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &moleculeAtcClassificationR{
				MolregnoMoleculeDictionary: o,
			}
		} else {
			rel.R.MolregnoMoleculeDictionary = o
		}
	}
	return nil
}

// AddMolregnoMoleculeFracClassifications adds the given related objects to the existing relationships
// of the molecule_dictionary, optionally inserting them as new records.
// Appends related to o.R.MolregnoMoleculeFracClassifications.
// Sets related.R.MolregnoMoleculeDictionary appropriately.
func (o *MoleculeDictionary) AddMolregnoMoleculeFracClassifications(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MoleculeFracClassification) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Molregno = o.Molregno
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"molecule_frac_classification\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
				strmangle.WhereClause("\"", "\"", 0, moleculeFracClassificationPrimaryKeyColumns),
			)
			values := []interface{}{o.Molregno, rel.MolFracID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Molregno = o.Molregno
		}
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			MolregnoMoleculeFracClassifications: related,
		}
	} else {
		o.R.MolregnoMoleculeFracClassifications = append(o.R.MolregnoMoleculeFracClassifications, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &moleculeFracClassificationR{
				MolregnoMoleculeDictionary: o,
			}
		} else {
			rel.R.MolregnoMoleculeDictionary = o
		}
	}
	return nil
}

// AddParentMolregnoMoleculeHierarchies adds the given related objects to the existing relationships
// of the molecule_dictionary, optionally inserting them as new records.
// Appends related to o.R.ParentMolregnoMoleculeHierarchies.
// Sets related.R.ParentMolregnoMoleculeDictionary appropriately.
func (o *MoleculeDictionary) AddParentMolregnoMoleculeHierarchies(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MoleculeHierarchy) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ParentMolregno, o.Molregno)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"molecule_hierarchy\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"parent_molregno"}),
				strmangle.WhereClause("\"", "\"", 0, moleculeHierarchyPrimaryKeyColumns),
			)
			values := []interface{}{o.Molregno, rel.Molregno}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ParentMolregno, o.Molregno)
		}
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			ParentMolregnoMoleculeHierarchies: related,
		}
	} else {
		o.R.ParentMolregnoMoleculeHierarchies = append(o.R.ParentMolregnoMoleculeHierarchies, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &moleculeHierarchyR{
				ParentMolregnoMoleculeDictionary: o,
			}
		} else {
			rel.R.ParentMolregnoMoleculeDictionary = o
		}
	}
	return nil
}

// SetParentMolregnoMoleculeHierarchies removes all previously related items of the
// molecule_dictionary replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ParentMolregnoMoleculeDictionary's ParentMolregnoMoleculeHierarchies accordingly.
// Replaces o.R.ParentMolregnoMoleculeHierarchies with related.
// Sets related.R.ParentMolregnoMoleculeDictionary's ParentMolregnoMoleculeHierarchies accordingly.
func (o *MoleculeDictionary) SetParentMolregnoMoleculeHierarchies(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MoleculeHierarchy) error {
	query := "update \"molecule_hierarchy\" set \"parent_molregno\" = null where \"parent_molregno\" = ?"
	values := []interface{}{o.Molregno}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ParentMolregnoMoleculeHierarchies {
			queries.SetScanner(&rel.ParentMolregno, nil)
			if rel.R == nil {
				continue
			}

			rel.R.ParentMolregnoMoleculeDictionary = nil
		}
		o.R.ParentMolregnoMoleculeHierarchies = nil
	}

	return o.AddParentMolregnoMoleculeHierarchies(ctx, exec, insert, related...)
}

// RemoveParentMolregnoMoleculeHierarchies relationships from objects passed in.
// Removes related items from R.ParentMolregnoMoleculeHierarchies (uses pointer comparison, removal does not keep order)
// Sets related.R.ParentMolregnoMoleculeDictionary.
func (o *MoleculeDictionary) RemoveParentMolregnoMoleculeHierarchies(ctx context.Context, exec boil.ContextExecutor, related ...*MoleculeHierarchy) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ParentMolregno, nil)
		if rel.R != nil {
			rel.R.ParentMolregnoMoleculeDictionary = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("parent_molregno")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ParentMolregnoMoleculeHierarchies {
			if rel != ri {
				continue
			}

			ln := len(o.R.ParentMolregnoMoleculeHierarchies)
			if ln > 1 && i < ln-1 {
				o.R.ParentMolregnoMoleculeHierarchies[i] = o.R.ParentMolregnoMoleculeHierarchies[ln-1]
			}
			o.R.ParentMolregnoMoleculeHierarchies = o.R.ParentMolregnoMoleculeHierarchies[:ln-1]
			break
		}
	}

	return nil
}

// AddActiveMolregnoMoleculeHierarchies adds the given related objects to the existing relationships
// of the molecule_dictionary, optionally inserting them as new records.
// Appends related to o.R.ActiveMolregnoMoleculeHierarchies.
// Sets related.R.ActiveMolregnoMoleculeDictionary appropriately.
func (o *MoleculeDictionary) AddActiveMolregnoMoleculeHierarchies(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MoleculeHierarchy) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ActiveMolregno, o.Molregno)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"molecule_hierarchy\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"active_molregno"}),
				strmangle.WhereClause("\"", "\"", 0, moleculeHierarchyPrimaryKeyColumns),
			)
			values := []interface{}{o.Molregno, rel.Molregno}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ActiveMolregno, o.Molregno)
		}
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			ActiveMolregnoMoleculeHierarchies: related,
		}
	} else {
		o.R.ActiveMolregnoMoleculeHierarchies = append(o.R.ActiveMolregnoMoleculeHierarchies, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &moleculeHierarchyR{
				ActiveMolregnoMoleculeDictionary: o,
			}
		} else {
			rel.R.ActiveMolregnoMoleculeDictionary = o
		}
	}
	return nil
}

// SetActiveMolregnoMoleculeHierarchies removes all previously related items of the
// molecule_dictionary replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.ActiveMolregnoMoleculeDictionary's ActiveMolregnoMoleculeHierarchies accordingly.
// Replaces o.R.ActiveMolregnoMoleculeHierarchies with related.
// Sets related.R.ActiveMolregnoMoleculeDictionary's ActiveMolregnoMoleculeHierarchies accordingly.
func (o *MoleculeDictionary) SetActiveMolregnoMoleculeHierarchies(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MoleculeHierarchy) error {
	query := "update \"molecule_hierarchy\" set \"active_molregno\" = null where \"active_molregno\" = ?"
	values := []interface{}{o.Molregno}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.ActiveMolregnoMoleculeHierarchies {
			queries.SetScanner(&rel.ActiveMolregno, nil)
			if rel.R == nil {
				continue
			}

			rel.R.ActiveMolregnoMoleculeDictionary = nil
		}
		o.R.ActiveMolregnoMoleculeHierarchies = nil
	}

	return o.AddActiveMolregnoMoleculeHierarchies(ctx, exec, insert, related...)
}

// RemoveActiveMolregnoMoleculeHierarchies relationships from objects passed in.
// Removes related items from R.ActiveMolregnoMoleculeHierarchies (uses pointer comparison, removal does not keep order)
// Sets related.R.ActiveMolregnoMoleculeDictionary.
func (o *MoleculeDictionary) RemoveActiveMolregnoMoleculeHierarchies(ctx context.Context, exec boil.ContextExecutor, related ...*MoleculeHierarchy) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ActiveMolregno, nil)
		if rel.R != nil {
			rel.R.ActiveMolregnoMoleculeDictionary = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("active_molregno")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.ActiveMolregnoMoleculeHierarchies {
			if rel != ri {
				continue
			}

			ln := len(o.R.ActiveMolregnoMoleculeHierarchies)
			if ln > 1 && i < ln-1 {
				o.R.ActiveMolregnoMoleculeHierarchies[i] = o.R.ActiveMolregnoMoleculeHierarchies[ln-1]
			}
			o.R.ActiveMolregnoMoleculeHierarchies = o.R.ActiveMolregnoMoleculeHierarchies[:ln-1]
			break
		}
	}

	return nil
}

// AddMolregnoMoleculeHracClassifications adds the given related objects to the existing relationships
// of the molecule_dictionary, optionally inserting them as new records.
// Appends related to o.R.MolregnoMoleculeHracClassifications.
// Sets related.R.MolregnoMoleculeDictionary appropriately.
func (o *MoleculeDictionary) AddMolregnoMoleculeHracClassifications(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MoleculeHracClassification) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Molregno = o.Molregno
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"molecule_hrac_classification\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
				strmangle.WhereClause("\"", "\"", 0, moleculeHracClassificationPrimaryKeyColumns),
			)
			values := []interface{}{o.Molregno, rel.MolHracID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Molregno = o.Molregno
		}
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			MolregnoMoleculeHracClassifications: related,
		}
	} else {
		o.R.MolregnoMoleculeHracClassifications = append(o.R.MolregnoMoleculeHracClassifications, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &moleculeHracClassificationR{
				MolregnoMoleculeDictionary: o,
			}
		} else {
			rel.R.MolregnoMoleculeDictionary = o
		}
	}
	return nil
}

// AddMolregnoMoleculeIracClassifications adds the given related objects to the existing relationships
// of the molecule_dictionary, optionally inserting them as new records.
// Appends related to o.R.MolregnoMoleculeIracClassifications.
// Sets related.R.MolregnoMoleculeDictionary appropriately.
func (o *MoleculeDictionary) AddMolregnoMoleculeIracClassifications(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MoleculeIracClassification) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Molregno = o.Molregno
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"molecule_irac_classification\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
				strmangle.WhereClause("\"", "\"", 0, moleculeIracClassificationPrimaryKeyColumns),
			)
			values := []interface{}{o.Molregno, rel.MolIracID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Molregno = o.Molregno
		}
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			MolregnoMoleculeIracClassifications: related,
		}
	} else {
		o.R.MolregnoMoleculeIracClassifications = append(o.R.MolregnoMoleculeIracClassifications, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &moleculeIracClassificationR{
				MolregnoMoleculeDictionary: o,
			}
		} else {
			rel.R.MolregnoMoleculeDictionary = o
		}
	}
	return nil
}

// AddMolregnoMoleculeSynonyms adds the given related objects to the existing relationships
// of the molecule_dictionary, optionally inserting them as new records.
// Appends related to o.R.MolregnoMoleculeSynonyms.
// Sets related.R.MolregnoMoleculeDictionary appropriately.
func (o *MoleculeDictionary) AddMolregnoMoleculeSynonyms(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*MoleculeSynonym) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.Molregno = o.Molregno
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"molecule_synonyms\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
				strmangle.WhereClause("\"", "\"", 0, moleculeSynonymPrimaryKeyColumns),
			)
			values := []interface{}{o.Molregno, rel.MolsynID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.Molregno = o.Molregno
		}
	}

	if o.R == nil {
		o.R = &moleculeDictionaryR{
			MolregnoMoleculeSynonyms: related,
		}
	} else {
		o.R.MolregnoMoleculeSynonyms = append(o.R.MolregnoMoleculeSynonyms, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &moleculeSynonymR{
				MolregnoMoleculeDictionary: o,
			}
		} else {
			rel.R.MolregnoMoleculeDictionary = o
		}
	}
	return nil
}

// MoleculeDictionaries retrieves all the records using an executor.
func MoleculeDictionaries(mods ...qm.QueryMod) moleculeDictionaryQuery {
	mods = append(mods, qm.From("\"molecule_dictionary\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"molecule_dictionary\".*"})
	}

	return moleculeDictionaryQuery{q}
}

// FindMoleculeDictionary retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindMoleculeDictionary(ctx context.Context, exec boil.ContextExecutor, molregno int64, selectCols ...string) (*MoleculeDictionary, error) {
	moleculeDictionaryObj := &MoleculeDictionary{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"molecule_dictionary\" where \"molregno\"=?", sel,
	)

	q := queries.Raw(query, molregno)

	err := q.Bind(ctx, exec, moleculeDictionaryObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from molecule_dictionary")
	}

	if err = moleculeDictionaryObj.doAfterSelectHooks(ctx, exec); err != nil {
		return moleculeDictionaryObj, err
	}

	return moleculeDictionaryObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *MoleculeDictionary) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no molecule_dictionary provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(moleculeDictionaryColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	moleculeDictionaryInsertCacheMut.RLock()
	cache, cached := moleculeDictionaryInsertCache[key]
	moleculeDictionaryInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			moleculeDictionaryAllColumns,
			moleculeDictionaryColumnsWithDefault,
			moleculeDictionaryColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(moleculeDictionaryType, moleculeDictionaryMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(moleculeDictionaryType, moleculeDictionaryMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"molecule_dictionary\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"molecule_dictionary\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into molecule_dictionary")
	}

	if !cached {
		moleculeDictionaryInsertCacheMut.Lock()
		moleculeDictionaryInsertCache[key] = cache
		moleculeDictionaryInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the MoleculeDictionary.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *MoleculeDictionary) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	moleculeDictionaryUpdateCacheMut.RLock()
	cache, cached := moleculeDictionaryUpdateCache[key]
	moleculeDictionaryUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			moleculeDictionaryAllColumns,
			moleculeDictionaryPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update molecule_dictionary, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"molecule_dictionary\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 0, wl),
			strmangle.WhereClause("\"", "\"", 0, moleculeDictionaryPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(moleculeDictionaryType, moleculeDictionaryMapping, append(wl, moleculeDictionaryPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update molecule_dictionary row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for molecule_dictionary")
	}

	if !cached {
		moleculeDictionaryUpdateCacheMut.Lock()
		moleculeDictionaryUpdateCache[key] = cache
		moleculeDictionaryUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q moleculeDictionaryQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for molecule_dictionary")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for molecule_dictionary")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o MoleculeDictionarySlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), moleculeDictionaryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"molecule_dictionary\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, moleculeDictionaryPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in moleculeDictionary slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all moleculeDictionary")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *MoleculeDictionary) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no molecule_dictionary provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(moleculeDictionaryColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	moleculeDictionaryUpsertCacheMut.RLock()
	cache, cached := moleculeDictionaryUpsertCache[key]
	moleculeDictionaryUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			moleculeDictionaryAllColumns,
			moleculeDictionaryColumnsWithDefault,
			moleculeDictionaryColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			moleculeDictionaryAllColumns,
			moleculeDictionaryPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert molecule_dictionary, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(moleculeDictionaryPrimaryKeyColumns))
			copy(conflict, moleculeDictionaryPrimaryKeyColumns)
		}
		cache.query = buildUpsertQuerySQLite(dialect, "\"molecule_dictionary\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(moleculeDictionaryType, moleculeDictionaryMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(moleculeDictionaryType, moleculeDictionaryMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert molecule_dictionary")
	}

	if !cached {
		moleculeDictionaryUpsertCacheMut.Lock()
		moleculeDictionaryUpsertCache[key] = cache
		moleculeDictionaryUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single MoleculeDictionary record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *MoleculeDictionary) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no MoleculeDictionary provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), moleculeDictionaryPrimaryKeyMapping)
	sql := "DELETE FROM \"molecule_dictionary\" WHERE \"molregno\"=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from molecule_dictionary")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for molecule_dictionary")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q moleculeDictionaryQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no moleculeDictionaryQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from molecule_dictionary")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for molecule_dictionary")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o MoleculeDictionarySlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(moleculeDictionaryBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), moleculeDictionaryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"molecule_dictionary\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, moleculeDictionaryPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from moleculeDictionary slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for molecule_dictionary")
	}

	if len(moleculeDictionaryAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *MoleculeDictionary) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindMoleculeDictionary(ctx, exec, o.Molregno)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *MoleculeDictionarySlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := MoleculeDictionarySlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), moleculeDictionaryPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"molecule_dictionary\".* FROM \"molecule_dictionary\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, moleculeDictionaryPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in MoleculeDictionarySlice")
	}

	*o = slice

	return nil
}

// MoleculeDictionaryExists checks if the MoleculeDictionary row exists.
func MoleculeDictionaryExists(ctx context.Context, exec boil.ContextExecutor, molregno int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"molecule_dictionary\" where \"molregno\"=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, molregno)
	}
	row := exec.QueryRowContext(ctx, sql, molregno)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if molecule_dictionary exists")
	}

	return exists, nil
}
