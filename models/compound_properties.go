// Code generated by SQLBoiler 4.11.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// CompoundProperty is an object representing the database table.
type CompoundProperty struct {
	Molregno                 int64             `boil:"molregno" json:"molregno" toml:"molregno" yaml:"molregno"`
	MWFreebase               types.NullDecimal `boil:"mw_freebase" json:"mw_freebase,omitempty" toml:"mw_freebase" yaml:"mw_freebase,omitempty"`
	Alogp                    types.NullDecimal `boil:"alogp" json:"alogp,omitempty" toml:"alogp" yaml:"alogp,omitempty"`
	Hba                      null.Int64        `boil:"hba" json:"hba,omitempty" toml:"hba" yaml:"hba,omitempty"`
	HBD                      null.Int64        `boil:"hbd" json:"hbd,omitempty" toml:"hbd" yaml:"hbd,omitempty"`
	Psa                      types.NullDecimal `boil:"psa" json:"psa,omitempty" toml:"psa" yaml:"psa,omitempty"`
	RTB                      null.Int64        `boil:"rtb" json:"rtb,omitempty" toml:"rtb" yaml:"rtb,omitempty"`
	Ro3Pass                  null.String       `boil:"ro3_pass" json:"ro3_pass,omitempty" toml:"ro3_pass" yaml:"ro3_pass,omitempty"`
	NumRo5Violations         null.Int16        `boil:"num_ro5_violations" json:"num_ro5_violations,omitempty" toml:"num_ro5_violations" yaml:"num_ro5_violations,omitempty"`
	CXMostApka               types.NullDecimal `boil:"cx_most_apka" json:"cx_most_apka,omitempty" toml:"cx_most_apka" yaml:"cx_most_apka,omitempty"`
	CXMostBpka               types.NullDecimal `boil:"cx_most_bpka" json:"cx_most_bpka,omitempty" toml:"cx_most_bpka" yaml:"cx_most_bpka,omitempty"`
	CXLogp                   types.NullDecimal `boil:"cx_logp" json:"cx_logp,omitempty" toml:"cx_logp" yaml:"cx_logp,omitempty"`
	CXLogd                   types.NullDecimal `boil:"cx_logd" json:"cx_logd,omitempty" toml:"cx_logd" yaml:"cx_logd,omitempty"`
	MolecularSpecies         null.String       `boil:"molecular_species" json:"molecular_species,omitempty" toml:"molecular_species" yaml:"molecular_species,omitempty"`
	FullMWT                  types.NullDecimal `boil:"full_mwt" json:"full_mwt,omitempty" toml:"full_mwt" yaml:"full_mwt,omitempty"`
	AromaticRings            null.Int64        `boil:"aromatic_rings" json:"aromatic_rings,omitempty" toml:"aromatic_rings" yaml:"aromatic_rings,omitempty"`
	HeavyAtoms               null.Int64        `boil:"heavy_atoms" json:"heavy_atoms,omitempty" toml:"heavy_atoms" yaml:"heavy_atoms,omitempty"`
	QedWeighted              types.NullDecimal `boil:"qed_weighted" json:"qed_weighted,omitempty" toml:"qed_weighted" yaml:"qed_weighted,omitempty"`
	MWMonoisotopic           types.NullDecimal `boil:"mw_monoisotopic" json:"mw_monoisotopic,omitempty" toml:"mw_monoisotopic" yaml:"mw_monoisotopic,omitempty"`
	FullMolformula           null.String       `boil:"full_molformula" json:"full_molformula,omitempty" toml:"full_molformula" yaml:"full_molformula,omitempty"`
	HbaLipinski              null.Int64        `boil:"hba_lipinski" json:"hba_lipinski,omitempty" toml:"hba_lipinski" yaml:"hba_lipinski,omitempty"`
	HBDLipinski              null.Int64        `boil:"hbd_lipinski" json:"hbd_lipinski,omitempty" toml:"hbd_lipinski" yaml:"hbd_lipinski,omitempty"`
	NumLipinskiRo5Violations null.Int16        `boil:"num_lipinski_ro5_violations" json:"num_lipinski_ro5_violations,omitempty" toml:"num_lipinski_ro5_violations" yaml:"num_lipinski_ro5_violations,omitempty"`

	R *compoundPropertyR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L compoundPropertyL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var CompoundPropertyColumns = struct {
	Molregno                 string
	MWFreebase               string
	Alogp                    string
	Hba                      string
	HBD                      string
	Psa                      string
	RTB                      string
	Ro3Pass                  string
	NumRo5Violations         string
	CXMostApka               string
	CXMostBpka               string
	CXLogp                   string
	CXLogd                   string
	MolecularSpecies         string
	FullMWT                  string
	AromaticRings            string
	HeavyAtoms               string
	QedWeighted              string
	MWMonoisotopic           string
	FullMolformula           string
	HbaLipinski              string
	HBDLipinski              string
	NumLipinskiRo5Violations string
}{
	Molregno:                 "molregno",
	MWFreebase:               "mw_freebase",
	Alogp:                    "alogp",
	Hba:                      "hba",
	HBD:                      "hbd",
	Psa:                      "psa",
	RTB:                      "rtb",
	Ro3Pass:                  "ro3_pass",
	NumRo5Violations:         "num_ro5_violations",
	CXMostApka:               "cx_most_apka",
	CXMostBpka:               "cx_most_bpka",
	CXLogp:                   "cx_logp",
	CXLogd:                   "cx_logd",
	MolecularSpecies:         "molecular_species",
	FullMWT:                  "full_mwt",
	AromaticRings:            "aromatic_rings",
	HeavyAtoms:               "heavy_atoms",
	QedWeighted:              "qed_weighted",
	MWMonoisotopic:           "mw_monoisotopic",
	FullMolformula:           "full_molformula",
	HbaLipinski:              "hba_lipinski",
	HBDLipinski:              "hbd_lipinski",
	NumLipinskiRo5Violations: "num_lipinski_ro5_violations",
}

var CompoundPropertyTableColumns = struct {
	Molregno                 string
	MWFreebase               string
	Alogp                    string
	Hba                      string
	HBD                      string
	Psa                      string
	RTB                      string
	Ro3Pass                  string
	NumRo5Violations         string
	CXMostApka               string
	CXMostBpka               string
	CXLogp                   string
	CXLogd                   string
	MolecularSpecies         string
	FullMWT                  string
	AromaticRings            string
	HeavyAtoms               string
	QedWeighted              string
	MWMonoisotopic           string
	FullMolformula           string
	HbaLipinski              string
	HBDLipinski              string
	NumLipinskiRo5Violations string
}{
	Molregno:                 "compound_properties.molregno",
	MWFreebase:               "compound_properties.mw_freebase",
	Alogp:                    "compound_properties.alogp",
	Hba:                      "compound_properties.hba",
	HBD:                      "compound_properties.hbd",
	Psa:                      "compound_properties.psa",
	RTB:                      "compound_properties.rtb",
	Ro3Pass:                  "compound_properties.ro3_pass",
	NumRo5Violations:         "compound_properties.num_ro5_violations",
	CXMostApka:               "compound_properties.cx_most_apka",
	CXMostBpka:               "compound_properties.cx_most_bpka",
	CXLogp:                   "compound_properties.cx_logp",
	CXLogd:                   "compound_properties.cx_logd",
	MolecularSpecies:         "compound_properties.molecular_species",
	FullMWT:                  "compound_properties.full_mwt",
	AromaticRings:            "compound_properties.aromatic_rings",
	HeavyAtoms:               "compound_properties.heavy_atoms",
	QedWeighted:              "compound_properties.qed_weighted",
	MWMonoisotopic:           "compound_properties.mw_monoisotopic",
	FullMolformula:           "compound_properties.full_molformula",
	HbaLipinski:              "compound_properties.hba_lipinski",
	HBDLipinski:              "compound_properties.hbd_lipinski",
	NumLipinskiRo5Violations: "compound_properties.num_lipinski_ro5_violations",
}

// Generated where

var CompoundPropertyWhere = struct {
	Molregno                 whereHelperint64
	MWFreebase               whereHelpertypes_NullDecimal
	Alogp                    whereHelpertypes_NullDecimal
	Hba                      whereHelpernull_Int64
	HBD                      whereHelpernull_Int64
	Psa                      whereHelpertypes_NullDecimal
	RTB                      whereHelpernull_Int64
	Ro3Pass                  whereHelpernull_String
	NumRo5Violations         whereHelpernull_Int16
	CXMostApka               whereHelpertypes_NullDecimal
	CXMostBpka               whereHelpertypes_NullDecimal
	CXLogp                   whereHelpertypes_NullDecimal
	CXLogd                   whereHelpertypes_NullDecimal
	MolecularSpecies         whereHelpernull_String
	FullMWT                  whereHelpertypes_NullDecimal
	AromaticRings            whereHelpernull_Int64
	HeavyAtoms               whereHelpernull_Int64
	QedWeighted              whereHelpertypes_NullDecimal
	MWMonoisotopic           whereHelpertypes_NullDecimal
	FullMolformula           whereHelpernull_String
	HbaLipinski              whereHelpernull_Int64
	HBDLipinski              whereHelpernull_Int64
	NumLipinskiRo5Violations whereHelpernull_Int16
}{
	Molregno:                 whereHelperint64{field: "\"compound_properties\".\"molregno\""},
	MWFreebase:               whereHelpertypes_NullDecimal{field: "\"compound_properties\".\"mw_freebase\""},
	Alogp:                    whereHelpertypes_NullDecimal{field: "\"compound_properties\".\"alogp\""},
	Hba:                      whereHelpernull_Int64{field: "\"compound_properties\".\"hba\""},
	HBD:                      whereHelpernull_Int64{field: "\"compound_properties\".\"hbd\""},
	Psa:                      whereHelpertypes_NullDecimal{field: "\"compound_properties\".\"psa\""},
	RTB:                      whereHelpernull_Int64{field: "\"compound_properties\".\"rtb\""},
	Ro3Pass:                  whereHelpernull_String{field: "\"compound_properties\".\"ro3_pass\""},
	NumRo5Violations:         whereHelpernull_Int16{field: "\"compound_properties\".\"num_ro5_violations\""},
	CXMostApka:               whereHelpertypes_NullDecimal{field: "\"compound_properties\".\"cx_most_apka\""},
	CXMostBpka:               whereHelpertypes_NullDecimal{field: "\"compound_properties\".\"cx_most_bpka\""},
	CXLogp:                   whereHelpertypes_NullDecimal{field: "\"compound_properties\".\"cx_logp\""},
	CXLogd:                   whereHelpertypes_NullDecimal{field: "\"compound_properties\".\"cx_logd\""},
	MolecularSpecies:         whereHelpernull_String{field: "\"compound_properties\".\"molecular_species\""},
	FullMWT:                  whereHelpertypes_NullDecimal{field: "\"compound_properties\".\"full_mwt\""},
	AromaticRings:            whereHelpernull_Int64{field: "\"compound_properties\".\"aromatic_rings\""},
	HeavyAtoms:               whereHelpernull_Int64{field: "\"compound_properties\".\"heavy_atoms\""},
	QedWeighted:              whereHelpertypes_NullDecimal{field: "\"compound_properties\".\"qed_weighted\""},
	MWMonoisotopic:           whereHelpertypes_NullDecimal{field: "\"compound_properties\".\"mw_monoisotopic\""},
	FullMolformula:           whereHelpernull_String{field: "\"compound_properties\".\"full_molformula\""},
	HbaLipinski:              whereHelpernull_Int64{field: "\"compound_properties\".\"hba_lipinski\""},
	HBDLipinski:              whereHelpernull_Int64{field: "\"compound_properties\".\"hbd_lipinski\""},
	NumLipinskiRo5Violations: whereHelpernull_Int16{field: "\"compound_properties\".\"num_lipinski_ro5_violations\""},
}

// CompoundPropertyRels is where relationship names are stored.
var CompoundPropertyRels = struct {
	MolregnoMoleculeDictionary string
}{
	MolregnoMoleculeDictionary: "MolregnoMoleculeDictionary",
}

// compoundPropertyR is where relationships are stored.
type compoundPropertyR struct {
	MolregnoMoleculeDictionary *MoleculeDictionary `boil:"MolregnoMoleculeDictionary" json:"MolregnoMoleculeDictionary" toml:"MolregnoMoleculeDictionary" yaml:"MolregnoMoleculeDictionary"`
}

// NewStruct creates a new relationship struct
func (*compoundPropertyR) NewStruct() *compoundPropertyR {
	return &compoundPropertyR{}
}

func (r *compoundPropertyR) GetMolregnoMoleculeDictionary() *MoleculeDictionary {
	if r == nil {
		return nil
	}
	return r.MolregnoMoleculeDictionary
}

// compoundPropertyL is where Load methods for each relationship are stored.
type compoundPropertyL struct{}

var (
	compoundPropertyAllColumns            = []string{"molregno", "mw_freebase", "alogp", "hba", "hbd", "psa", "rtb", "ro3_pass", "num_ro5_violations", "cx_most_apka", "cx_most_bpka", "cx_logp", "cx_logd", "molecular_species", "full_mwt", "aromatic_rings", "heavy_atoms", "qed_weighted", "mw_monoisotopic", "full_molformula", "hba_lipinski", "hbd_lipinski", "num_lipinski_ro5_violations"}
	compoundPropertyColumnsWithoutDefault = []string{"molregno"}
	compoundPropertyColumnsWithDefault    = []string{"mw_freebase", "alogp", "hba", "hbd", "psa", "rtb", "ro3_pass", "num_ro5_violations", "cx_most_apka", "cx_most_bpka", "cx_logp", "cx_logd", "molecular_species", "full_mwt", "aromatic_rings", "heavy_atoms", "qed_weighted", "mw_monoisotopic", "full_molformula", "hba_lipinski", "hbd_lipinski", "num_lipinski_ro5_violations"}
	compoundPropertyPrimaryKeyColumns     = []string{"molregno"}
	compoundPropertyGeneratedColumns      = []string{}
)

type (
	// CompoundPropertySlice is an alias for a slice of pointers to CompoundProperty.
	// This should almost always be used instead of []CompoundProperty.
	CompoundPropertySlice []*CompoundProperty
	// CompoundPropertyHook is the signature for custom CompoundProperty hook methods
	CompoundPropertyHook func(context.Context, boil.ContextExecutor, *CompoundProperty) error

	compoundPropertyQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	compoundPropertyType                 = reflect.TypeOf(&CompoundProperty{})
	compoundPropertyMapping              = queries.MakeStructMapping(compoundPropertyType)
	compoundPropertyPrimaryKeyMapping, _ = queries.BindMapping(compoundPropertyType, compoundPropertyMapping, compoundPropertyPrimaryKeyColumns)
	compoundPropertyInsertCacheMut       sync.RWMutex
	compoundPropertyInsertCache          = make(map[string]insertCache)
	compoundPropertyUpdateCacheMut       sync.RWMutex
	compoundPropertyUpdateCache          = make(map[string]updateCache)
	compoundPropertyUpsertCacheMut       sync.RWMutex
	compoundPropertyUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var compoundPropertyAfterSelectHooks []CompoundPropertyHook

var compoundPropertyBeforeInsertHooks []CompoundPropertyHook
var compoundPropertyAfterInsertHooks []CompoundPropertyHook

var compoundPropertyBeforeUpdateHooks []CompoundPropertyHook
var compoundPropertyAfterUpdateHooks []CompoundPropertyHook

var compoundPropertyBeforeDeleteHooks []CompoundPropertyHook
var compoundPropertyAfterDeleteHooks []CompoundPropertyHook

var compoundPropertyBeforeUpsertHooks []CompoundPropertyHook
var compoundPropertyAfterUpsertHooks []CompoundPropertyHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *CompoundProperty) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compoundPropertyAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *CompoundProperty) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compoundPropertyBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *CompoundProperty) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compoundPropertyAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *CompoundProperty) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compoundPropertyBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *CompoundProperty) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compoundPropertyAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *CompoundProperty) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compoundPropertyBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *CompoundProperty) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compoundPropertyAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *CompoundProperty) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compoundPropertyBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *CompoundProperty) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range compoundPropertyAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddCompoundPropertyHook registers your hook function for all future operations.
func AddCompoundPropertyHook(hookPoint boil.HookPoint, compoundPropertyHook CompoundPropertyHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		compoundPropertyAfterSelectHooks = append(compoundPropertyAfterSelectHooks, compoundPropertyHook)
	case boil.BeforeInsertHook:
		compoundPropertyBeforeInsertHooks = append(compoundPropertyBeforeInsertHooks, compoundPropertyHook)
	case boil.AfterInsertHook:
		compoundPropertyAfterInsertHooks = append(compoundPropertyAfterInsertHooks, compoundPropertyHook)
	case boil.BeforeUpdateHook:
		compoundPropertyBeforeUpdateHooks = append(compoundPropertyBeforeUpdateHooks, compoundPropertyHook)
	case boil.AfterUpdateHook:
		compoundPropertyAfterUpdateHooks = append(compoundPropertyAfterUpdateHooks, compoundPropertyHook)
	case boil.BeforeDeleteHook:
		compoundPropertyBeforeDeleteHooks = append(compoundPropertyBeforeDeleteHooks, compoundPropertyHook)
	case boil.AfterDeleteHook:
		compoundPropertyAfterDeleteHooks = append(compoundPropertyAfterDeleteHooks, compoundPropertyHook)
	case boil.BeforeUpsertHook:
		compoundPropertyBeforeUpsertHooks = append(compoundPropertyBeforeUpsertHooks, compoundPropertyHook)
	case boil.AfterUpsertHook:
		compoundPropertyAfterUpsertHooks = append(compoundPropertyAfterUpsertHooks, compoundPropertyHook)
	}
}

// One returns a single compoundProperty record from the query.
func (q compoundPropertyQuery) One(ctx context.Context, exec boil.ContextExecutor) (*CompoundProperty, error) {
	o := &CompoundProperty{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for compound_properties")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all CompoundProperty records from the query.
func (q compoundPropertyQuery) All(ctx context.Context, exec boil.ContextExecutor) (CompoundPropertySlice, error) {
	var o []*CompoundProperty

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to CompoundProperty slice")
	}

	if len(compoundPropertyAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all CompoundProperty records in the query.
func (q compoundPropertyQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count compound_properties rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q compoundPropertyQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if compound_properties exists")
	}

	return count > 0, nil
}

// MolregnoMoleculeDictionary pointed to by the foreign key.
func (o *CompoundProperty) MolregnoMoleculeDictionary(mods ...qm.QueryMod) moleculeDictionaryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"molregno\" = ?", o.Molregno),
	}

	queryMods = append(queryMods, mods...)

	return MoleculeDictionaries(queryMods...)
}

// LoadMolregnoMoleculeDictionary allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (compoundPropertyL) LoadMolregnoMoleculeDictionary(ctx context.Context, e boil.ContextExecutor, singular bool, maybeCompoundProperty interface{}, mods queries.Applicator) error {
	var slice []*CompoundProperty
	var object *CompoundProperty

	if singular {
		object = maybeCompoundProperty.(*CompoundProperty)
	} else {
		slice = *maybeCompoundProperty.(*[]*CompoundProperty)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &compoundPropertyR{}
		}
		args = append(args, object.Molregno)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &compoundPropertyR{}
			}

			for _, a := range args {
				if a == obj.Molregno {
					continue Outer
				}
			}

			args = append(args, obj.Molregno)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`molecule_dictionary`),
		qm.WhereIn(`molecule_dictionary.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MoleculeDictionary")
	}

	var resultSlice []*MoleculeDictionary
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MoleculeDictionary")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for molecule_dictionary")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for molecule_dictionary")
	}

	if len(compoundPropertyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MolregnoMoleculeDictionary = foreign
		if foreign.R == nil {
			foreign.R = &moleculeDictionaryR{}
		}
		foreign.R.MolregnoCompoundProperty = object
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.Molregno == foreign.Molregno {
				local.R.MolregnoMoleculeDictionary = foreign
				if foreign.R == nil {
					foreign.R = &moleculeDictionaryR{}
				}
				foreign.R.MolregnoCompoundProperty = local
				break
			}
		}
	}

	return nil
}

// SetMolregnoMoleculeDictionary of the compoundProperty to the related item.
// Sets o.R.MolregnoMoleculeDictionary to related.
// Adds o to related.R.MolregnoCompoundProperty.
func (o *CompoundProperty) SetMolregnoMoleculeDictionary(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MoleculeDictionary) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"compound_properties\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
		strmangle.WhereClause("\"", "\"", 0, compoundPropertyPrimaryKeyColumns),
	)
	values := []interface{}{related.Molregno, o.Molregno}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.Molregno = related.Molregno
	if o.R == nil {
		o.R = &compoundPropertyR{
			MolregnoMoleculeDictionary: related,
		}
	} else {
		o.R.MolregnoMoleculeDictionary = related
	}

	if related.R == nil {
		related.R = &moleculeDictionaryR{
			MolregnoCompoundProperty: o,
		}
	} else {
		related.R.MolregnoCompoundProperty = o
	}

	return nil
}

// CompoundProperties retrieves all the records using an executor.
func CompoundProperties(mods ...qm.QueryMod) compoundPropertyQuery {
	mods = append(mods, qm.From("\"compound_properties\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"compound_properties\".*"})
	}

	return compoundPropertyQuery{q}
}

// FindCompoundProperty retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindCompoundProperty(ctx context.Context, exec boil.ContextExecutor, molregno int64, selectCols ...string) (*CompoundProperty, error) {
	compoundPropertyObj := &CompoundProperty{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"compound_properties\" where \"molregno\"=?", sel,
	)

	q := queries.Raw(query, molregno)

	err := q.Bind(ctx, exec, compoundPropertyObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from compound_properties")
	}

	if err = compoundPropertyObj.doAfterSelectHooks(ctx, exec); err != nil {
		return compoundPropertyObj, err
	}

	return compoundPropertyObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *CompoundProperty) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no compound_properties provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(compoundPropertyColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	compoundPropertyInsertCacheMut.RLock()
	cache, cached := compoundPropertyInsertCache[key]
	compoundPropertyInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			compoundPropertyAllColumns,
			compoundPropertyColumnsWithDefault,
			compoundPropertyColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(compoundPropertyType, compoundPropertyMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(compoundPropertyType, compoundPropertyMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"compound_properties\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"compound_properties\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into compound_properties")
	}

	if !cached {
		compoundPropertyInsertCacheMut.Lock()
		compoundPropertyInsertCache[key] = cache
		compoundPropertyInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the CompoundProperty.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *CompoundProperty) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	compoundPropertyUpdateCacheMut.RLock()
	cache, cached := compoundPropertyUpdateCache[key]
	compoundPropertyUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			compoundPropertyAllColumns,
			compoundPropertyPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update compound_properties, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"compound_properties\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 0, wl),
			strmangle.WhereClause("\"", "\"", 0, compoundPropertyPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(compoundPropertyType, compoundPropertyMapping, append(wl, compoundPropertyPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update compound_properties row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for compound_properties")
	}

	if !cached {
		compoundPropertyUpdateCacheMut.Lock()
		compoundPropertyUpdateCache[key] = cache
		compoundPropertyUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q compoundPropertyQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for compound_properties")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for compound_properties")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o CompoundPropertySlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), compoundPropertyPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"compound_properties\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, compoundPropertyPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in compoundProperty slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all compoundProperty")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *CompoundProperty) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no compound_properties provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(compoundPropertyColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	compoundPropertyUpsertCacheMut.RLock()
	cache, cached := compoundPropertyUpsertCache[key]
	compoundPropertyUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			compoundPropertyAllColumns,
			compoundPropertyColumnsWithDefault,
			compoundPropertyColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			compoundPropertyAllColumns,
			compoundPropertyPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert compound_properties, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(compoundPropertyPrimaryKeyColumns))
			copy(conflict, compoundPropertyPrimaryKeyColumns)
		}
		cache.query = buildUpsertQuerySQLite(dialect, "\"compound_properties\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(compoundPropertyType, compoundPropertyMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(compoundPropertyType, compoundPropertyMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert compound_properties")
	}

	if !cached {
		compoundPropertyUpsertCacheMut.Lock()
		compoundPropertyUpsertCache[key] = cache
		compoundPropertyUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single CompoundProperty record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *CompoundProperty) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no CompoundProperty provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), compoundPropertyPrimaryKeyMapping)
	sql := "DELETE FROM \"compound_properties\" WHERE \"molregno\"=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from compound_properties")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for compound_properties")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q compoundPropertyQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no compoundPropertyQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from compound_properties")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for compound_properties")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o CompoundPropertySlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(compoundPropertyBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), compoundPropertyPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"compound_properties\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, compoundPropertyPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from compoundProperty slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for compound_properties")
	}

	if len(compoundPropertyAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *CompoundProperty) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindCompoundProperty(ctx, exec, o.Molregno)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *CompoundPropertySlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := CompoundPropertySlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), compoundPropertyPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"compound_properties\".* FROM \"compound_properties\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, compoundPropertyPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in CompoundPropertySlice")
	}

	*o = slice

	return nil
}

// CompoundPropertyExists checks if the CompoundProperty row exists.
func CompoundPropertyExists(ctx context.Context, exec boil.ContextExecutor, molregno int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"compound_properties\" where \"molregno\"=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, molregno)
	}
	row := exec.QueryRowContext(ctx, sql, molregno)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if compound_properties exists")
	}

	return exists, nil
}
