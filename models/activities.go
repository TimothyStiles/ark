// Code generated by SQLBoiler 4.11.0 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/sqlboiler/v4/types"
	"github.com/volatiletech/strmangle"
)

// Activity is an object representing the database table.
type Activity struct {
	ActivityID          int64             `boil:"activity_id" json:"activity_id" toml:"activity_id" yaml:"activity_id"`
	AssayID             int64             `boil:"assay_id" json:"assay_id" toml:"assay_id" yaml:"assay_id"`
	DocID               null.Int64        `boil:"doc_id" json:"doc_id,omitempty" toml:"doc_id" yaml:"doc_id,omitempty"`
	RecordID            int64             `boil:"record_id" json:"record_id" toml:"record_id" yaml:"record_id"`
	Molregno            null.Int64        `boil:"molregno" json:"molregno,omitempty" toml:"molregno" yaml:"molregno,omitempty"`
	StandardRelation    null.String       `boil:"standard_relation" json:"standard_relation,omitempty" toml:"standard_relation" yaml:"standard_relation,omitempty"`
	StandardValue       types.NullDecimal `boil:"standard_value" json:"standard_value,omitempty" toml:"standard_value" yaml:"standard_value,omitempty"`
	StandardUnits       null.String       `boil:"standard_units" json:"standard_units,omitempty" toml:"standard_units" yaml:"standard_units,omitempty"`
	StandardFlag        null.Int16        `boil:"standard_flag" json:"standard_flag,omitempty" toml:"standard_flag" yaml:"standard_flag,omitempty"`
	StandardType        null.String       `boil:"standard_type" json:"standard_type,omitempty" toml:"standard_type" yaml:"standard_type,omitempty"`
	ActivityComment     null.String       `boil:"activity_comment" json:"activity_comment,omitempty" toml:"activity_comment" yaml:"activity_comment,omitempty"`
	DataValidityComment null.String       `boil:"data_validity_comment" json:"data_validity_comment,omitempty" toml:"data_validity_comment" yaml:"data_validity_comment,omitempty"`
	PotentialDuplicate  null.Int16        `boil:"potential_duplicate" json:"potential_duplicate,omitempty" toml:"potential_duplicate" yaml:"potential_duplicate,omitempty"`
	PchemblValue        types.NullDecimal `boil:"pchembl_value" json:"pchembl_value,omitempty" toml:"pchembl_value" yaml:"pchembl_value,omitempty"`
	BaoEndpoint         null.String       `boil:"bao_endpoint" json:"bao_endpoint,omitempty" toml:"bao_endpoint" yaml:"bao_endpoint,omitempty"`
	UoUnits             null.String       `boil:"uo_units" json:"uo_units,omitempty" toml:"uo_units" yaml:"uo_units,omitempty"`
	QudtUnits           null.String       `boil:"qudt_units" json:"qudt_units,omitempty" toml:"qudt_units" yaml:"qudt_units,omitempty"`
	Toid                null.Int64        `boil:"toid" json:"toid,omitempty" toml:"toid" yaml:"toid,omitempty"`
	UpperValue          types.NullDecimal `boil:"upper_value" json:"upper_value,omitempty" toml:"upper_value" yaml:"upper_value,omitempty"`
	StandardUpperValue  types.NullDecimal `boil:"standard_upper_value" json:"standard_upper_value,omitempty" toml:"standard_upper_value" yaml:"standard_upper_value,omitempty"`
	SRCID               null.Int64        `boil:"src_id" json:"src_id,omitempty" toml:"src_id" yaml:"src_id,omitempty"`
	Type                string            `boil:"type" json:"type" toml:"type" yaml:"type"`
	Relation            null.String       `boil:"relation" json:"relation,omitempty" toml:"relation" yaml:"relation,omitempty"`
	Value               types.NullDecimal `boil:"value" json:"value,omitempty" toml:"value" yaml:"value,omitempty"`
	Units               null.String       `boil:"units" json:"units,omitempty" toml:"units" yaml:"units,omitempty"`
	TextValue           null.String       `boil:"text_value" json:"text_value,omitempty" toml:"text_value" yaml:"text_value,omitempty"`
	StandardTextValue   null.String       `boil:"standard_text_value" json:"standard_text_value,omitempty" toml:"standard_text_value" yaml:"standard_text_value,omitempty"`

	R *activityR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L activityL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var ActivityColumns = struct {
	ActivityID          string
	AssayID             string
	DocID               string
	RecordID            string
	Molregno            string
	StandardRelation    string
	StandardValue       string
	StandardUnits       string
	StandardFlag        string
	StandardType        string
	ActivityComment     string
	DataValidityComment string
	PotentialDuplicate  string
	PchemblValue        string
	BaoEndpoint         string
	UoUnits             string
	QudtUnits           string
	Toid                string
	UpperValue          string
	StandardUpperValue  string
	SRCID               string
	Type                string
	Relation            string
	Value               string
	Units               string
	TextValue           string
	StandardTextValue   string
}{
	ActivityID:          "activity_id",
	AssayID:             "assay_id",
	DocID:               "doc_id",
	RecordID:            "record_id",
	Molregno:            "molregno",
	StandardRelation:    "standard_relation",
	StandardValue:       "standard_value",
	StandardUnits:       "standard_units",
	StandardFlag:        "standard_flag",
	StandardType:        "standard_type",
	ActivityComment:     "activity_comment",
	DataValidityComment: "data_validity_comment",
	PotentialDuplicate:  "potential_duplicate",
	PchemblValue:        "pchembl_value",
	BaoEndpoint:         "bao_endpoint",
	UoUnits:             "uo_units",
	QudtUnits:           "qudt_units",
	Toid:                "toid",
	UpperValue:          "upper_value",
	StandardUpperValue:  "standard_upper_value",
	SRCID:               "src_id",
	Type:                "type",
	Relation:            "relation",
	Value:               "value",
	Units:               "units",
	TextValue:           "text_value",
	StandardTextValue:   "standard_text_value",
}

var ActivityTableColumns = struct {
	ActivityID          string
	AssayID             string
	DocID               string
	RecordID            string
	Molregno            string
	StandardRelation    string
	StandardValue       string
	StandardUnits       string
	StandardFlag        string
	StandardType        string
	ActivityComment     string
	DataValidityComment string
	PotentialDuplicate  string
	PchemblValue        string
	BaoEndpoint         string
	UoUnits             string
	QudtUnits           string
	Toid                string
	UpperValue          string
	StandardUpperValue  string
	SRCID               string
	Type                string
	Relation            string
	Value               string
	Units               string
	TextValue           string
	StandardTextValue   string
}{
	ActivityID:          "activities.activity_id",
	AssayID:             "activities.assay_id",
	DocID:               "activities.doc_id",
	RecordID:            "activities.record_id",
	Molregno:            "activities.molregno",
	StandardRelation:    "activities.standard_relation",
	StandardValue:       "activities.standard_value",
	StandardUnits:       "activities.standard_units",
	StandardFlag:        "activities.standard_flag",
	StandardType:        "activities.standard_type",
	ActivityComment:     "activities.activity_comment",
	DataValidityComment: "activities.data_validity_comment",
	PotentialDuplicate:  "activities.potential_duplicate",
	PchemblValue:        "activities.pchembl_value",
	BaoEndpoint:         "activities.bao_endpoint",
	UoUnits:             "activities.uo_units",
	QudtUnits:           "activities.qudt_units",
	Toid:                "activities.toid",
	UpperValue:          "activities.upper_value",
	StandardUpperValue:  "activities.standard_upper_value",
	SRCID:               "activities.src_id",
	Type:                "activities.type",
	Relation:            "activities.relation",
	Value:               "activities.value",
	Units:               "activities.units",
	TextValue:           "activities.text_value",
	StandardTextValue:   "activities.standard_text_value",
}

// Generated where

type whereHelperint64 struct{ field string }

func (w whereHelperint64) EQ(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.EQ, x) }
func (w whereHelperint64) NEQ(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.NEQ, x) }
func (w whereHelperint64) LT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.LT, x) }
func (w whereHelperint64) LTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.LTE, x) }
func (w whereHelperint64) GT(x int64) qm.QueryMod  { return qmhelper.Where(w.field, qmhelper.GT, x) }
func (w whereHelperint64) GTE(x int64) qm.QueryMod { return qmhelper.Where(w.field, qmhelper.GTE, x) }
func (w whereHelperint64) IN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereIn(fmt.Sprintf("%s IN ?", w.field), values...)
}
func (w whereHelperint64) NIN(slice []int64) qm.QueryMod {
	values := make([]interface{}, 0, len(slice))
	for _, value := range slice {
		values = append(values, value)
	}
	return qm.WhereNotIn(fmt.Sprintf("%s NOT IN ?", w.field), values...)
}

type whereHelpernull_Int64 struct{ field string }

func (w whereHelpernull_Int64) EQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int64) NEQ(x null.Int64) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int64) LT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int64) LTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int64) GT(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int64) GTE(x null.Int64) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Int64) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int64) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

type whereHelpertypes_NullDecimal struct{ field string }

func (w whereHelpertypes_NullDecimal) EQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpertypes_NullDecimal) NEQ(x types.NullDecimal) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpertypes_NullDecimal) LT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpertypes_NullDecimal) LTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpertypes_NullDecimal) GT(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpertypes_NullDecimal) GTE(x types.NullDecimal) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpertypes_NullDecimal) IsNull() qm.QueryMod { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpertypes_NullDecimal) IsNotNull() qm.QueryMod {
	return qmhelper.WhereIsNotNull(w.field)
}

type whereHelpernull_Int16 struct{ field string }

func (w whereHelpernull_Int16) EQ(x null.Int16) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, false, x)
}
func (w whereHelpernull_Int16) NEQ(x null.Int16) qm.QueryMod {
	return qmhelper.WhereNullEQ(w.field, true, x)
}
func (w whereHelpernull_Int16) LT(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LT, x)
}
func (w whereHelpernull_Int16) LTE(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.LTE, x)
}
func (w whereHelpernull_Int16) GT(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GT, x)
}
func (w whereHelpernull_Int16) GTE(x null.Int16) qm.QueryMod {
	return qmhelper.Where(w.field, qmhelper.GTE, x)
}

func (w whereHelpernull_Int16) IsNull() qm.QueryMod    { return qmhelper.WhereIsNull(w.field) }
func (w whereHelpernull_Int16) IsNotNull() qm.QueryMod { return qmhelper.WhereIsNotNull(w.field) }

var ActivityWhere = struct {
	ActivityID          whereHelperint64
	AssayID             whereHelperint64
	DocID               whereHelpernull_Int64
	RecordID            whereHelperint64
	Molregno            whereHelpernull_Int64
	StandardRelation    whereHelpernull_String
	StandardValue       whereHelpertypes_NullDecimal
	StandardUnits       whereHelpernull_String
	StandardFlag        whereHelpernull_Int16
	StandardType        whereHelpernull_String
	ActivityComment     whereHelpernull_String
	DataValidityComment whereHelpernull_String
	PotentialDuplicate  whereHelpernull_Int16
	PchemblValue        whereHelpertypes_NullDecimal
	BaoEndpoint         whereHelpernull_String
	UoUnits             whereHelpernull_String
	QudtUnits           whereHelpernull_String
	Toid                whereHelpernull_Int64
	UpperValue          whereHelpertypes_NullDecimal
	StandardUpperValue  whereHelpertypes_NullDecimal
	SRCID               whereHelpernull_Int64
	Type                whereHelperstring
	Relation            whereHelpernull_String
	Value               whereHelpertypes_NullDecimal
	Units               whereHelpernull_String
	TextValue           whereHelpernull_String
	StandardTextValue   whereHelpernull_String
}{
	ActivityID:          whereHelperint64{field: "\"activities\".\"activity_id\""},
	AssayID:             whereHelperint64{field: "\"activities\".\"assay_id\""},
	DocID:               whereHelpernull_Int64{field: "\"activities\".\"doc_id\""},
	RecordID:            whereHelperint64{field: "\"activities\".\"record_id\""},
	Molregno:            whereHelpernull_Int64{field: "\"activities\".\"molregno\""},
	StandardRelation:    whereHelpernull_String{field: "\"activities\".\"standard_relation\""},
	StandardValue:       whereHelpertypes_NullDecimal{field: "\"activities\".\"standard_value\""},
	StandardUnits:       whereHelpernull_String{field: "\"activities\".\"standard_units\""},
	StandardFlag:        whereHelpernull_Int16{field: "\"activities\".\"standard_flag\""},
	StandardType:        whereHelpernull_String{field: "\"activities\".\"standard_type\""},
	ActivityComment:     whereHelpernull_String{field: "\"activities\".\"activity_comment\""},
	DataValidityComment: whereHelpernull_String{field: "\"activities\".\"data_validity_comment\""},
	PotentialDuplicate:  whereHelpernull_Int16{field: "\"activities\".\"potential_duplicate\""},
	PchemblValue:        whereHelpertypes_NullDecimal{field: "\"activities\".\"pchembl_value\""},
	BaoEndpoint:         whereHelpernull_String{field: "\"activities\".\"bao_endpoint\""},
	UoUnits:             whereHelpernull_String{field: "\"activities\".\"uo_units\""},
	QudtUnits:           whereHelpernull_String{field: "\"activities\".\"qudt_units\""},
	Toid:                whereHelpernull_Int64{field: "\"activities\".\"toid\""},
	UpperValue:          whereHelpertypes_NullDecimal{field: "\"activities\".\"upper_value\""},
	StandardUpperValue:  whereHelpertypes_NullDecimal{field: "\"activities\".\"standard_upper_value\""},
	SRCID:               whereHelpernull_Int64{field: "\"activities\".\"src_id\""},
	Type:                whereHelperstring{field: "\"activities\".\"type\""},
	Relation:            whereHelpernull_String{field: "\"activities\".\"relation\""},
	Value:               whereHelpertypes_NullDecimal{field: "\"activities\".\"value\""},
	Units:               whereHelpernull_String{field: "\"activities\".\"units\""},
	TextValue:           whereHelpernull_String{field: "\"activities\".\"text_value\""},
	StandardTextValue:   whereHelpernull_String{field: "\"activities\".\"standard_text_value\""},
}

// ActivityRels is where relationship names are stored.
var ActivityRels = struct {
	DataValidityCommentDataValidityLookup string
	SRC                                   string
	Record                                string
	MolregnoMoleculeDictionary            string
	Doc                                   string
	BaoEndpointBioassayOntology           string
	Assay                                 string
	LigandEff                             string
	ActivityProperties                    string
	ActivitySuppMaps                      string
	PredictedBindingDomains               string
}{
	DataValidityCommentDataValidityLookup: "DataValidityCommentDataValidityLookup",
	SRC:                                   "SRC",
	Record:                                "Record",
	MolregnoMoleculeDictionary:            "MolregnoMoleculeDictionary",
	Doc:                                   "Doc",
	BaoEndpointBioassayOntology:           "BaoEndpointBioassayOntology",
	Assay:                                 "Assay",
	LigandEff:                             "LigandEff",
	ActivityProperties:                    "ActivityProperties",
	ActivitySuppMaps:                      "ActivitySuppMaps",
	PredictedBindingDomains:               "PredictedBindingDomains",
}

// activityR is where relationships are stored.
type activityR struct {
	DataValidityCommentDataValidityLookup *DataValidityLookup         `boil:"DataValidityCommentDataValidityLookup" json:"DataValidityCommentDataValidityLookup" toml:"DataValidityCommentDataValidityLookup" yaml:"DataValidityCommentDataValidityLookup"`
	SRC                                   *Source                     `boil:"SRC" json:"SRC" toml:"SRC" yaml:"SRC"`
	Record                                *CompoundRecord             `boil:"Record" json:"Record" toml:"Record" yaml:"Record"`
	MolregnoMoleculeDictionary            *MoleculeDictionary         `boil:"MolregnoMoleculeDictionary" json:"MolregnoMoleculeDictionary" toml:"MolregnoMoleculeDictionary" yaml:"MolregnoMoleculeDictionary"`
	Doc                                   *Doc                        `boil:"Doc" json:"Doc" toml:"Doc" yaml:"Doc"`
	BaoEndpointBioassayOntology           *BioassayOntology           `boil:"BaoEndpointBioassayOntology" json:"BaoEndpointBioassayOntology" toml:"BaoEndpointBioassayOntology" yaml:"BaoEndpointBioassayOntology"`
	Assay                                 *Assay                      `boil:"Assay" json:"Assay" toml:"Assay" yaml:"Assay"`
	LigandEff                             *LigandEff                  `boil:"LigandEff" json:"LigandEff" toml:"LigandEff" yaml:"LigandEff"`
	ActivityProperties                    ActivityPropertySlice       `boil:"ActivityProperties" json:"ActivityProperties" toml:"ActivityProperties" yaml:"ActivityProperties"`
	ActivitySuppMaps                      ActivitySuppMapSlice        `boil:"ActivitySuppMaps" json:"ActivitySuppMaps" toml:"ActivitySuppMaps" yaml:"ActivitySuppMaps"`
	PredictedBindingDomains               PredictedBindingDomainSlice `boil:"PredictedBindingDomains" json:"PredictedBindingDomains" toml:"PredictedBindingDomains" yaml:"PredictedBindingDomains"`
}

// NewStruct creates a new relationship struct
func (*activityR) NewStruct() *activityR {
	return &activityR{}
}

func (r *activityR) GetDataValidityCommentDataValidityLookup() *DataValidityLookup {
	if r == nil {
		return nil
	}
	return r.DataValidityCommentDataValidityLookup
}

func (r *activityR) GetSRC() *Source {
	if r == nil {
		return nil
	}
	return r.SRC
}

func (r *activityR) GetRecord() *CompoundRecord {
	if r == nil {
		return nil
	}
	return r.Record
}

func (r *activityR) GetMolregnoMoleculeDictionary() *MoleculeDictionary {
	if r == nil {
		return nil
	}
	return r.MolregnoMoleculeDictionary
}

func (r *activityR) GetDoc() *Doc {
	if r == nil {
		return nil
	}
	return r.Doc
}

func (r *activityR) GetBaoEndpointBioassayOntology() *BioassayOntology {
	if r == nil {
		return nil
	}
	return r.BaoEndpointBioassayOntology
}

func (r *activityR) GetAssay() *Assay {
	if r == nil {
		return nil
	}
	return r.Assay
}

func (r *activityR) GetLigandEff() *LigandEff {
	if r == nil {
		return nil
	}
	return r.LigandEff
}

func (r *activityR) GetActivityProperties() ActivityPropertySlice {
	if r == nil {
		return nil
	}
	return r.ActivityProperties
}

func (r *activityR) GetActivitySuppMaps() ActivitySuppMapSlice {
	if r == nil {
		return nil
	}
	return r.ActivitySuppMaps
}

func (r *activityR) GetPredictedBindingDomains() PredictedBindingDomainSlice {
	if r == nil {
		return nil
	}
	return r.PredictedBindingDomains
}

// activityL is where Load methods for each relationship are stored.
type activityL struct{}

var (
	activityAllColumns            = []string{"activity_id", "assay_id", "doc_id", "record_id", "molregno", "standard_relation", "standard_value", "standard_units", "standard_flag", "standard_type", "activity_comment", "data_validity_comment", "potential_duplicate", "pchembl_value", "bao_endpoint", "uo_units", "qudt_units", "toid", "upper_value", "standard_upper_value", "src_id", "type", "relation", "value", "units", "text_value", "standard_text_value"}
	activityColumnsWithoutDefault = []string{"activity_id", "assay_id", "record_id", "type"}
	activityColumnsWithDefault    = []string{"doc_id", "molregno", "standard_relation", "standard_value", "standard_units", "standard_flag", "standard_type", "activity_comment", "data_validity_comment", "potential_duplicate", "pchembl_value", "bao_endpoint", "uo_units", "qudt_units", "toid", "upper_value", "standard_upper_value", "src_id", "relation", "value", "units", "text_value", "standard_text_value"}
	activityPrimaryKeyColumns     = []string{"activity_id"}
	activityGeneratedColumns      = []string{}
)

type (
	// ActivitySlice is an alias for a slice of pointers to Activity.
	// This should almost always be used instead of []Activity.
	ActivitySlice []*Activity
	// ActivityHook is the signature for custom Activity hook methods
	ActivityHook func(context.Context, boil.ContextExecutor, *Activity) error

	activityQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	activityType                 = reflect.TypeOf(&Activity{})
	activityMapping              = queries.MakeStructMapping(activityType)
	activityPrimaryKeyMapping, _ = queries.BindMapping(activityType, activityMapping, activityPrimaryKeyColumns)
	activityInsertCacheMut       sync.RWMutex
	activityInsertCache          = make(map[string]insertCache)
	activityUpdateCacheMut       sync.RWMutex
	activityUpdateCache          = make(map[string]updateCache)
	activityUpsertCacheMut       sync.RWMutex
	activityUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var activityAfterSelectHooks []ActivityHook

var activityBeforeInsertHooks []ActivityHook
var activityAfterInsertHooks []ActivityHook

var activityBeforeUpdateHooks []ActivityHook
var activityAfterUpdateHooks []ActivityHook

var activityBeforeDeleteHooks []ActivityHook
var activityAfterDeleteHooks []ActivityHook

var activityBeforeUpsertHooks []ActivityHook
var activityAfterUpsertHooks []ActivityHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Activity) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range activityAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Activity) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range activityBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Activity) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range activityAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Activity) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range activityBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Activity) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range activityAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Activity) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range activityBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Activity) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range activityAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Activity) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range activityBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Activity) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range activityAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddActivityHook registers your hook function for all future operations.
func AddActivityHook(hookPoint boil.HookPoint, activityHook ActivityHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		activityAfterSelectHooks = append(activityAfterSelectHooks, activityHook)
	case boil.BeforeInsertHook:
		activityBeforeInsertHooks = append(activityBeforeInsertHooks, activityHook)
	case boil.AfterInsertHook:
		activityAfterInsertHooks = append(activityAfterInsertHooks, activityHook)
	case boil.BeforeUpdateHook:
		activityBeforeUpdateHooks = append(activityBeforeUpdateHooks, activityHook)
	case boil.AfterUpdateHook:
		activityAfterUpdateHooks = append(activityAfterUpdateHooks, activityHook)
	case boil.BeforeDeleteHook:
		activityBeforeDeleteHooks = append(activityBeforeDeleteHooks, activityHook)
	case boil.AfterDeleteHook:
		activityAfterDeleteHooks = append(activityAfterDeleteHooks, activityHook)
	case boil.BeforeUpsertHook:
		activityBeforeUpsertHooks = append(activityBeforeUpsertHooks, activityHook)
	case boil.AfterUpsertHook:
		activityAfterUpsertHooks = append(activityAfterUpsertHooks, activityHook)
	}
}

// One returns a single activity record from the query.
func (q activityQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Activity, error) {
	o := &Activity{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for activities")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all Activity records from the query.
func (q activityQuery) All(ctx context.Context, exec boil.ContextExecutor) (ActivitySlice, error) {
	var o []*Activity

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Activity slice")
	}

	if len(activityAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all Activity records in the query.
func (q activityQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count activities rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q activityQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if activities exists")
	}

	return count > 0, nil
}

// DataValidityCommentDataValidityLookup pointed to by the foreign key.
func (o *Activity) DataValidityCommentDataValidityLookup(mods ...qm.QueryMod) dataValidityLookupQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"data_validity_comment\" = ?", o.DataValidityComment),
	}

	queryMods = append(queryMods, mods...)

	return DataValidityLookups(queryMods...)
}

// SRC pointed to by the foreign key.
func (o *Activity) SRC(mods ...qm.QueryMod) sourceQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"src_id\" = ?", o.SRCID),
	}

	queryMods = append(queryMods, mods...)

	return Sources(queryMods...)
}

// Record pointed to by the foreign key.
func (o *Activity) Record(mods ...qm.QueryMod) compoundRecordQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"record_id\" = ?", o.RecordID),
	}

	queryMods = append(queryMods, mods...)

	return CompoundRecords(queryMods...)
}

// MolregnoMoleculeDictionary pointed to by the foreign key.
func (o *Activity) MolregnoMoleculeDictionary(mods ...qm.QueryMod) moleculeDictionaryQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"molregno\" = ?", o.Molregno),
	}

	queryMods = append(queryMods, mods...)

	return MoleculeDictionaries(queryMods...)
}

// Doc pointed to by the foreign key.
func (o *Activity) Doc(mods ...qm.QueryMod) docQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"doc_id\" = ?", o.DocID),
	}

	queryMods = append(queryMods, mods...)

	return Docs(queryMods...)
}

// BaoEndpointBioassayOntology pointed to by the foreign key.
func (o *Activity) BaoEndpointBioassayOntology(mods ...qm.QueryMod) bioassayOntologyQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"bao_id\" = ?", o.BaoEndpoint),
	}

	queryMods = append(queryMods, mods...)

	return BioassayOntologies(queryMods...)
}

// Assay pointed to by the foreign key.
func (o *Activity) Assay(mods ...qm.QueryMod) assayQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"assay_id\" = ?", o.AssayID),
	}

	queryMods = append(queryMods, mods...)

	return Assays(queryMods...)
}

// LigandEff pointed to by the foreign key.
func (o *Activity) LigandEff(mods ...qm.QueryMod) ligandEffQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"activity_id\" = ?", o.ActivityID),
	}

	queryMods = append(queryMods, mods...)

	return LigandEffs(queryMods...)
}

// ActivityProperties retrieves all the activity_property's ActivityProperties with an executor.
func (o *Activity) ActivityProperties(mods ...qm.QueryMod) activityPropertyQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"activity_properties\".\"activity_id\"=?", o.ActivityID),
	)

	return ActivityProperties(queryMods...)
}

// ActivitySuppMaps retrieves all the activity_supp_map's ActivitySuppMaps with an executor.
func (o *Activity) ActivitySuppMaps(mods ...qm.QueryMod) activitySuppMapQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"activity_supp_map\".\"activity_id\"=?", o.ActivityID),
	)

	return ActivitySuppMaps(queryMods...)
}

// PredictedBindingDomains retrieves all the predicted_binding_domain's PredictedBindingDomains with an executor.
func (o *Activity) PredictedBindingDomains(mods ...qm.QueryMod) predictedBindingDomainQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"predicted_binding_domains\".\"activity_id\"=?", o.ActivityID),
	)

	return PredictedBindingDomains(queryMods...)
}

// LoadDataValidityCommentDataValidityLookup allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (activityL) LoadDataValidityCommentDataValidityLookup(ctx context.Context, e boil.ContextExecutor, singular bool, maybeActivity interface{}, mods queries.Applicator) error {
	var slice []*Activity
	var object *Activity

	if singular {
		object = maybeActivity.(*Activity)
	} else {
		slice = *maybeActivity.(*[]*Activity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &activityR{}
		}
		if !queries.IsNil(object.DataValidityComment) {
			args = append(args, object.DataValidityComment)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &activityR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DataValidityComment) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DataValidityComment) {
				args = append(args, obj.DataValidityComment)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`data_validity_lookup`),
		qm.WhereIn(`data_validity_lookup.data_validity_comment in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load DataValidityLookup")
	}

	var resultSlice []*DataValidityLookup
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice DataValidityLookup")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for data_validity_lookup")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for data_validity_lookup")
	}

	if len(activityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.DataValidityCommentDataValidityLookup = foreign
		if foreign.R == nil {
			foreign.R = &dataValidityLookupR{}
		}
		foreign.R.DataValidityCommentActivities = append(foreign.R.DataValidityCommentActivities, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DataValidityComment, foreign.DataValidityComment) {
				local.R.DataValidityCommentDataValidityLookup = foreign
				if foreign.R == nil {
					foreign.R = &dataValidityLookupR{}
				}
				foreign.R.DataValidityCommentActivities = append(foreign.R.DataValidityCommentActivities, local)
				break
			}
		}
	}

	return nil
}

// LoadSRC allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (activityL) LoadSRC(ctx context.Context, e boil.ContextExecutor, singular bool, maybeActivity interface{}, mods queries.Applicator) error {
	var slice []*Activity
	var object *Activity

	if singular {
		object = maybeActivity.(*Activity)
	} else {
		slice = *maybeActivity.(*[]*Activity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &activityR{}
		}
		if !queries.IsNil(object.SRCID) {
			args = append(args, object.SRCID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &activityR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.SRCID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.SRCID) {
				args = append(args, obj.SRCID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`source`),
		qm.WhereIn(`source.src_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Source")
	}

	var resultSlice []*Source
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Source")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for source")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for source")
	}

	if len(activityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SRC = foreign
		if foreign.R == nil {
			foreign.R = &sourceR{}
		}
		foreign.R.SRCActivities = append(foreign.R.SRCActivities, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SRCID, foreign.SRCID) {
				local.R.SRC = foreign
				if foreign.R == nil {
					foreign.R = &sourceR{}
				}
				foreign.R.SRCActivities = append(foreign.R.SRCActivities, local)
				break
			}
		}
	}

	return nil
}

// LoadRecord allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (activityL) LoadRecord(ctx context.Context, e boil.ContextExecutor, singular bool, maybeActivity interface{}, mods queries.Applicator) error {
	var slice []*Activity
	var object *Activity

	if singular {
		object = maybeActivity.(*Activity)
	} else {
		slice = *maybeActivity.(*[]*Activity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &activityR{}
		}
		args = append(args, object.RecordID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &activityR{}
			}

			for _, a := range args {
				if a == obj.RecordID {
					continue Outer
				}
			}

			args = append(args, obj.RecordID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`compound_records`),
		qm.WhereIn(`compound_records.record_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load CompoundRecord")
	}

	var resultSlice []*CompoundRecord
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice CompoundRecord")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for compound_records")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for compound_records")
	}

	if len(activityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Record = foreign
		if foreign.R == nil {
			foreign.R = &compoundRecordR{}
		}
		foreign.R.RecordActivities = append(foreign.R.RecordActivities, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.RecordID == foreign.RecordID {
				local.R.Record = foreign
				if foreign.R == nil {
					foreign.R = &compoundRecordR{}
				}
				foreign.R.RecordActivities = append(foreign.R.RecordActivities, local)
				break
			}
		}
	}

	return nil
}

// LoadMolregnoMoleculeDictionary allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (activityL) LoadMolregnoMoleculeDictionary(ctx context.Context, e boil.ContextExecutor, singular bool, maybeActivity interface{}, mods queries.Applicator) error {
	var slice []*Activity
	var object *Activity

	if singular {
		object = maybeActivity.(*Activity)
	} else {
		slice = *maybeActivity.(*[]*Activity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &activityR{}
		}
		if !queries.IsNil(object.Molregno) {
			args = append(args, object.Molregno)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &activityR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.Molregno) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.Molregno) {
				args = append(args, obj.Molregno)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`molecule_dictionary`),
		qm.WhereIn(`molecule_dictionary.molregno in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load MoleculeDictionary")
	}

	var resultSlice []*MoleculeDictionary
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice MoleculeDictionary")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for molecule_dictionary")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for molecule_dictionary")
	}

	if len(activityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.MolregnoMoleculeDictionary = foreign
		if foreign.R == nil {
			foreign.R = &moleculeDictionaryR{}
		}
		foreign.R.MolregnoActivities = append(foreign.R.MolregnoActivities, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.Molregno, foreign.Molregno) {
				local.R.MolregnoMoleculeDictionary = foreign
				if foreign.R == nil {
					foreign.R = &moleculeDictionaryR{}
				}
				foreign.R.MolregnoActivities = append(foreign.R.MolregnoActivities, local)
				break
			}
		}
	}

	return nil
}

// LoadDoc allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (activityL) LoadDoc(ctx context.Context, e boil.ContextExecutor, singular bool, maybeActivity interface{}, mods queries.Applicator) error {
	var slice []*Activity
	var object *Activity

	if singular {
		object = maybeActivity.(*Activity)
	} else {
		slice = *maybeActivity.(*[]*Activity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &activityR{}
		}
		if !queries.IsNil(object.DocID) {
			args = append(args, object.DocID)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &activityR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.DocID) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.DocID) {
				args = append(args, obj.DocID)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`docs`),
		qm.WhereIn(`docs.doc_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Doc")
	}

	var resultSlice []*Doc
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Doc")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for docs")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for docs")
	}

	if len(activityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Doc = foreign
		if foreign.R == nil {
			foreign.R = &docR{}
		}
		foreign.R.Activities = append(foreign.R.Activities, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.DocID, foreign.DocID) {
				local.R.Doc = foreign
				if foreign.R == nil {
					foreign.R = &docR{}
				}
				foreign.R.Activities = append(foreign.R.Activities, local)
				break
			}
		}
	}

	return nil
}

// LoadBaoEndpointBioassayOntology allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (activityL) LoadBaoEndpointBioassayOntology(ctx context.Context, e boil.ContextExecutor, singular bool, maybeActivity interface{}, mods queries.Applicator) error {
	var slice []*Activity
	var object *Activity

	if singular {
		object = maybeActivity.(*Activity)
	} else {
		slice = *maybeActivity.(*[]*Activity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &activityR{}
		}
		if !queries.IsNil(object.BaoEndpoint) {
			args = append(args, object.BaoEndpoint)
		}

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &activityR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.BaoEndpoint) {
					continue Outer
				}
			}

			if !queries.IsNil(obj.BaoEndpoint) {
				args = append(args, obj.BaoEndpoint)
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`bioassay_ontology`),
		qm.WhereIn(`bioassay_ontology.bao_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load BioassayOntology")
	}

	var resultSlice []*BioassayOntology
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice BioassayOntology")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for bioassay_ontology")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for bioassay_ontology")
	}

	if len(activityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.BaoEndpointBioassayOntology = foreign
		if foreign.R == nil {
			foreign.R = &bioassayOntologyR{}
		}
		foreign.R.BaoEndpointActivities = append(foreign.R.BaoEndpointActivities, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.BaoEndpoint, foreign.BaoID) {
				local.R.BaoEndpointBioassayOntology = foreign
				if foreign.R == nil {
					foreign.R = &bioassayOntologyR{}
				}
				foreign.R.BaoEndpointActivities = append(foreign.R.BaoEndpointActivities, local)
				break
			}
		}
	}

	return nil
}

// LoadAssay allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (activityL) LoadAssay(ctx context.Context, e boil.ContextExecutor, singular bool, maybeActivity interface{}, mods queries.Applicator) error {
	var slice []*Activity
	var object *Activity

	if singular {
		object = maybeActivity.(*Activity)
	} else {
		slice = *maybeActivity.(*[]*Activity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &activityR{}
		}
		args = append(args, object.AssayID)

	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &activityR{}
			}

			for _, a := range args {
				if a == obj.AssayID {
					continue Outer
				}
			}

			args = append(args, obj.AssayID)

		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`assays`),
		qm.WhereIn(`assays.assay_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Assay")
	}

	var resultSlice []*Assay
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Assay")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for assays")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for assays")
	}

	if len(activityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Assay = foreign
		if foreign.R == nil {
			foreign.R = &assayR{}
		}
		foreign.R.Activities = append(foreign.R.Activities, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.AssayID == foreign.AssayID {
				local.R.Assay = foreign
				if foreign.R == nil {
					foreign.R = &assayR{}
				}
				foreign.R.Activities = append(foreign.R.Activities, local)
				break
			}
		}
	}

	return nil
}

// LoadLigandEff allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (activityL) LoadLigandEff(ctx context.Context, e boil.ContextExecutor, singular bool, maybeActivity interface{}, mods queries.Applicator) error {
	var slice []*Activity
	var object *Activity

	if singular {
		object = maybeActivity.(*Activity)
	} else {
		slice = *maybeActivity.(*[]*Activity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &activityR{}
		}
		args = append(args, object.ActivityID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &activityR{}
			}

			for _, a := range args {
				if a == obj.ActivityID {
					continue Outer
				}
			}

			args = append(args, obj.ActivityID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`ligand_eff`),
		qm.WhereIn(`ligand_eff.activity_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load LigandEff")
	}

	var resultSlice []*LigandEff
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice LigandEff")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for ligand_eff")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for ligand_eff")
	}

	if len(activityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.LigandEff = foreign
		if foreign.R == nil {
			foreign.R = &ligandEffR{}
		}
		foreign.R.Activity = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ActivityID == foreign.ActivityID {
				local.R.LigandEff = foreign
				if foreign.R == nil {
					foreign.R = &ligandEffR{}
				}
				foreign.R.Activity = local
				break
			}
		}
	}

	return nil
}

// LoadActivityProperties allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (activityL) LoadActivityProperties(ctx context.Context, e boil.ContextExecutor, singular bool, maybeActivity interface{}, mods queries.Applicator) error {
	var slice []*Activity
	var object *Activity

	if singular {
		object = maybeActivity.(*Activity)
	} else {
		slice = *maybeActivity.(*[]*Activity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &activityR{}
		}
		args = append(args, object.ActivityID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &activityR{}
			}

			for _, a := range args {
				if a == obj.ActivityID {
					continue Outer
				}
			}

			args = append(args, obj.ActivityID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`activity_properties`),
		qm.WhereIn(`activity_properties.activity_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load activity_properties")
	}

	var resultSlice []*ActivityProperty
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice activity_properties")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on activity_properties")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for activity_properties")
	}

	if len(activityPropertyAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ActivityProperties = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &activityPropertyR{}
			}
			foreign.R.Activity = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ActivityID == foreign.ActivityID {
				local.R.ActivityProperties = append(local.R.ActivityProperties, foreign)
				if foreign.R == nil {
					foreign.R = &activityPropertyR{}
				}
				foreign.R.Activity = local
				break
			}
		}
	}

	return nil
}

// LoadActivitySuppMaps allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (activityL) LoadActivitySuppMaps(ctx context.Context, e boil.ContextExecutor, singular bool, maybeActivity interface{}, mods queries.Applicator) error {
	var slice []*Activity
	var object *Activity

	if singular {
		object = maybeActivity.(*Activity)
	} else {
		slice = *maybeActivity.(*[]*Activity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &activityR{}
		}
		args = append(args, object.ActivityID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &activityR{}
			}

			for _, a := range args {
				if a == obj.ActivityID {
					continue Outer
				}
			}

			args = append(args, obj.ActivityID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`activity_supp_map`),
		qm.WhereIn(`activity_supp_map.activity_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load activity_supp_map")
	}

	var resultSlice []*ActivitySuppMap
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice activity_supp_map")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on activity_supp_map")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for activity_supp_map")
	}

	if len(activitySuppMapAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.ActivitySuppMaps = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &activitySuppMapR{}
			}
			foreign.R.Activity = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ActivityID == foreign.ActivityID {
				local.R.ActivitySuppMaps = append(local.R.ActivitySuppMaps, foreign)
				if foreign.R == nil {
					foreign.R = &activitySuppMapR{}
				}
				foreign.R.Activity = local
				break
			}
		}
	}

	return nil
}

// LoadPredictedBindingDomains allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (activityL) LoadPredictedBindingDomains(ctx context.Context, e boil.ContextExecutor, singular bool, maybeActivity interface{}, mods queries.Applicator) error {
	var slice []*Activity
	var object *Activity

	if singular {
		object = maybeActivity.(*Activity)
	} else {
		slice = *maybeActivity.(*[]*Activity)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &activityR{}
		}
		args = append(args, object.ActivityID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &activityR{}
			}

			for _, a := range args {
				if queries.Equal(a, obj.ActivityID) {
					continue Outer
				}
			}

			args = append(args, obj.ActivityID)
		}
	}

	if len(args) == 0 {
		return nil
	}

	query := NewQuery(
		qm.From(`predicted_binding_domains`),
		qm.WhereIn(`predicted_binding_domains.activity_id in ?`, args...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load predicted_binding_domains")
	}

	var resultSlice []*PredictedBindingDomain
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice predicted_binding_domains")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on predicted_binding_domains")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for predicted_binding_domains")
	}

	if len(predictedBindingDomainAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PredictedBindingDomains = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &predictedBindingDomainR{}
			}
			foreign.R.Activity = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ActivityID, foreign.ActivityID) {
				local.R.PredictedBindingDomains = append(local.R.PredictedBindingDomains, foreign)
				if foreign.R == nil {
					foreign.R = &predictedBindingDomainR{}
				}
				foreign.R.Activity = local
				break
			}
		}
	}

	return nil
}

// SetDataValidityCommentDataValidityLookup of the activity to the related item.
// Sets o.R.DataValidityCommentDataValidityLookup to related.
// Adds o to related.R.DataValidityCommentActivities.
func (o *Activity) SetDataValidityCommentDataValidityLookup(ctx context.Context, exec boil.ContextExecutor, insert bool, related *DataValidityLookup) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"activities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"data_validity_comment"}),
		strmangle.WhereClause("\"", "\"", 0, activityPrimaryKeyColumns),
	)
	values := []interface{}{related.DataValidityComment, o.ActivityID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DataValidityComment, related.DataValidityComment)
	if o.R == nil {
		o.R = &activityR{
			DataValidityCommentDataValidityLookup: related,
		}
	} else {
		o.R.DataValidityCommentDataValidityLookup = related
	}

	if related.R == nil {
		related.R = &dataValidityLookupR{
			DataValidityCommentActivities: ActivitySlice{o},
		}
	} else {
		related.R.DataValidityCommentActivities = append(related.R.DataValidityCommentActivities, o)
	}

	return nil
}

// RemoveDataValidityCommentDataValidityLookup relationship.
// Sets o.R.DataValidityCommentDataValidityLookup to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Activity) RemoveDataValidityCommentDataValidityLookup(ctx context.Context, exec boil.ContextExecutor, related *DataValidityLookup) error {
	var err error

	queries.SetScanner(&o.DataValidityComment, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("data_validity_comment")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.DataValidityCommentDataValidityLookup = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.DataValidityCommentActivities {
		if queries.Equal(o.DataValidityComment, ri.DataValidityComment) {
			continue
		}

		ln := len(related.R.DataValidityCommentActivities)
		if ln > 1 && i < ln-1 {
			related.R.DataValidityCommentActivities[i] = related.R.DataValidityCommentActivities[ln-1]
		}
		related.R.DataValidityCommentActivities = related.R.DataValidityCommentActivities[:ln-1]
		break
	}
	return nil
}

// SetSRC of the activity to the related item.
// Sets o.R.SRC to related.
// Adds o to related.R.SRCActivities.
func (o *Activity) SetSRC(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Source) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"activities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"src_id"}),
		strmangle.WhereClause("\"", "\"", 0, activityPrimaryKeyColumns),
	)
	values := []interface{}{related.SRCID, o.ActivityID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SRCID, related.SRCID)
	if o.R == nil {
		o.R = &activityR{
			SRC: related,
		}
	} else {
		o.R.SRC = related
	}

	if related.R == nil {
		related.R = &sourceR{
			SRCActivities: ActivitySlice{o},
		}
	} else {
		related.R.SRCActivities = append(related.R.SRCActivities, o)
	}

	return nil
}

// RemoveSRC relationship.
// Sets o.R.SRC to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Activity) RemoveSRC(ctx context.Context, exec boil.ContextExecutor, related *Source) error {
	var err error

	queries.SetScanner(&o.SRCID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("src_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.SRC = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.SRCActivities {
		if queries.Equal(o.SRCID, ri.SRCID) {
			continue
		}

		ln := len(related.R.SRCActivities)
		if ln > 1 && i < ln-1 {
			related.R.SRCActivities[i] = related.R.SRCActivities[ln-1]
		}
		related.R.SRCActivities = related.R.SRCActivities[:ln-1]
		break
	}
	return nil
}

// SetRecord of the activity to the related item.
// Sets o.R.Record to related.
// Adds o to related.R.RecordActivities.
func (o *Activity) SetRecord(ctx context.Context, exec boil.ContextExecutor, insert bool, related *CompoundRecord) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"activities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"record_id"}),
		strmangle.WhereClause("\"", "\"", 0, activityPrimaryKeyColumns),
	)
	values := []interface{}{related.RecordID, o.ActivityID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.RecordID = related.RecordID
	if o.R == nil {
		o.R = &activityR{
			Record: related,
		}
	} else {
		o.R.Record = related
	}

	if related.R == nil {
		related.R = &compoundRecordR{
			RecordActivities: ActivitySlice{o},
		}
	} else {
		related.R.RecordActivities = append(related.R.RecordActivities, o)
	}

	return nil
}

// SetMolregnoMoleculeDictionary of the activity to the related item.
// Sets o.R.MolregnoMoleculeDictionary to related.
// Adds o to related.R.MolregnoActivities.
func (o *Activity) SetMolregnoMoleculeDictionary(ctx context.Context, exec boil.ContextExecutor, insert bool, related *MoleculeDictionary) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"activities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"molregno"}),
		strmangle.WhereClause("\"", "\"", 0, activityPrimaryKeyColumns),
	)
	values := []interface{}{related.Molregno, o.ActivityID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.Molregno, related.Molregno)
	if o.R == nil {
		o.R = &activityR{
			MolregnoMoleculeDictionary: related,
		}
	} else {
		o.R.MolregnoMoleculeDictionary = related
	}

	if related.R == nil {
		related.R = &moleculeDictionaryR{
			MolregnoActivities: ActivitySlice{o},
		}
	} else {
		related.R.MolregnoActivities = append(related.R.MolregnoActivities, o)
	}

	return nil
}

// RemoveMolregnoMoleculeDictionary relationship.
// Sets o.R.MolregnoMoleculeDictionary to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Activity) RemoveMolregnoMoleculeDictionary(ctx context.Context, exec boil.ContextExecutor, related *MoleculeDictionary) error {
	var err error

	queries.SetScanner(&o.Molregno, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("molregno")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.MolregnoMoleculeDictionary = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.MolregnoActivities {
		if queries.Equal(o.Molregno, ri.Molregno) {
			continue
		}

		ln := len(related.R.MolregnoActivities)
		if ln > 1 && i < ln-1 {
			related.R.MolregnoActivities[i] = related.R.MolregnoActivities[ln-1]
		}
		related.R.MolregnoActivities = related.R.MolregnoActivities[:ln-1]
		break
	}
	return nil
}

// SetDoc of the activity to the related item.
// Sets o.R.Doc to related.
// Adds o to related.R.Activities.
func (o *Activity) SetDoc(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Doc) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"activities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"doc_id"}),
		strmangle.WhereClause("\"", "\"", 0, activityPrimaryKeyColumns),
	)
	values := []interface{}{related.DocID, o.ActivityID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.DocID, related.DocID)
	if o.R == nil {
		o.R = &activityR{
			Doc: related,
		}
	} else {
		o.R.Doc = related
	}

	if related.R == nil {
		related.R = &docR{
			Activities: ActivitySlice{o},
		}
	} else {
		related.R.Activities = append(related.R.Activities, o)
	}

	return nil
}

// RemoveDoc relationship.
// Sets o.R.Doc to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Activity) RemoveDoc(ctx context.Context, exec boil.ContextExecutor, related *Doc) error {
	var err error

	queries.SetScanner(&o.DocID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("doc_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.Doc = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.Activities {
		if queries.Equal(o.DocID, ri.DocID) {
			continue
		}

		ln := len(related.R.Activities)
		if ln > 1 && i < ln-1 {
			related.R.Activities[i] = related.R.Activities[ln-1]
		}
		related.R.Activities = related.R.Activities[:ln-1]
		break
	}
	return nil
}

// SetBaoEndpointBioassayOntology of the activity to the related item.
// Sets o.R.BaoEndpointBioassayOntology to related.
// Adds o to related.R.BaoEndpointActivities.
func (o *Activity) SetBaoEndpointBioassayOntology(ctx context.Context, exec boil.ContextExecutor, insert bool, related *BioassayOntology) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"activities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"bao_endpoint"}),
		strmangle.WhereClause("\"", "\"", 0, activityPrimaryKeyColumns),
	)
	values := []interface{}{related.BaoID, o.ActivityID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.BaoEndpoint, related.BaoID)
	if o.R == nil {
		o.R = &activityR{
			BaoEndpointBioassayOntology: related,
		}
	} else {
		o.R.BaoEndpointBioassayOntology = related
	}

	if related.R == nil {
		related.R = &bioassayOntologyR{
			BaoEndpointActivities: ActivitySlice{o},
		}
	} else {
		related.R.BaoEndpointActivities = append(related.R.BaoEndpointActivities, o)
	}

	return nil
}

// RemoveBaoEndpointBioassayOntology relationship.
// Sets o.R.BaoEndpointBioassayOntology to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Activity) RemoveBaoEndpointBioassayOntology(ctx context.Context, exec boil.ContextExecutor, related *BioassayOntology) error {
	var err error

	queries.SetScanner(&o.BaoEndpoint, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("bao_endpoint")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.BaoEndpointBioassayOntology = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.BaoEndpointActivities {
		if queries.Equal(o.BaoEndpoint, ri.BaoEndpoint) {
			continue
		}

		ln := len(related.R.BaoEndpointActivities)
		if ln > 1 && i < ln-1 {
			related.R.BaoEndpointActivities[i] = related.R.BaoEndpointActivities[ln-1]
		}
		related.R.BaoEndpointActivities = related.R.BaoEndpointActivities[:ln-1]
		break
	}
	return nil
}

// SetAssay of the activity to the related item.
// Sets o.R.Assay to related.
// Adds o to related.R.Activities.
func (o *Activity) SetAssay(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Assay) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"activities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, []string{"assay_id"}),
		strmangle.WhereClause("\"", "\"", 0, activityPrimaryKeyColumns),
	)
	values := []interface{}{related.AssayID, o.ActivityID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.AssayID = related.AssayID
	if o.R == nil {
		o.R = &activityR{
			Assay: related,
		}
	} else {
		o.R.Assay = related
	}

	if related.R == nil {
		related.R = &assayR{
			Activities: ActivitySlice{o},
		}
	} else {
		related.R.Activities = append(related.R.Activities, o)
	}

	return nil
}

// SetLigandEff of the activity to the related item.
// Sets o.R.LigandEff to related.
// Adds o to related.R.Activity.
func (o *Activity) SetLigandEff(ctx context.Context, exec boil.ContextExecutor, insert bool, related *LigandEff) error {
	var err error

	if insert {
		related.ActivityID = o.ActivityID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"ligand_eff\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 0, []string{"activity_id"}),
			strmangle.WhereClause("\"", "\"", 0, ligandEffPrimaryKeyColumns),
		)
		values := []interface{}{o.ActivityID, related.ActivityID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.ActivityID = o.ActivityID
	}

	if o.R == nil {
		o.R = &activityR{
			LigandEff: related,
		}
	} else {
		o.R.LigandEff = related
	}

	if related.R == nil {
		related.R = &ligandEffR{
			Activity: o,
		}
	} else {
		related.R.Activity = o
	}
	return nil
}

// AddActivityProperties adds the given related objects to the existing relationships
// of the activity, optionally inserting them as new records.
// Appends related to o.R.ActivityProperties.
// Sets related.R.Activity appropriately.
func (o *Activity) AddActivityProperties(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ActivityProperty) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ActivityID = o.ActivityID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"activity_properties\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"activity_id"}),
				strmangle.WhereClause("\"", "\"", 0, activityPropertyPrimaryKeyColumns),
			)
			values := []interface{}{o.ActivityID, rel.ApID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ActivityID = o.ActivityID
		}
	}

	if o.R == nil {
		o.R = &activityR{
			ActivityProperties: related,
		}
	} else {
		o.R.ActivityProperties = append(o.R.ActivityProperties, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &activityPropertyR{
				Activity: o,
			}
		} else {
			rel.R.Activity = o
		}
	}
	return nil
}

// AddActivitySuppMaps adds the given related objects to the existing relationships
// of the activity, optionally inserting them as new records.
// Appends related to o.R.ActivitySuppMaps.
// Sets related.R.Activity appropriately.
func (o *Activity) AddActivitySuppMaps(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*ActivitySuppMap) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.ActivityID = o.ActivityID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"activity_supp_map\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"activity_id"}),
				strmangle.WhereClause("\"", "\"", 0, activitySuppMapPrimaryKeyColumns),
			)
			values := []interface{}{o.ActivityID, rel.ActsmID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.ActivityID = o.ActivityID
		}
	}

	if o.R == nil {
		o.R = &activityR{
			ActivitySuppMaps: related,
		}
	} else {
		o.R.ActivitySuppMaps = append(o.R.ActivitySuppMaps, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &activitySuppMapR{
				Activity: o,
			}
		} else {
			rel.R.Activity = o
		}
	}
	return nil
}

// AddPredictedBindingDomains adds the given related objects to the existing relationships
// of the activity, optionally inserting them as new records.
// Appends related to o.R.PredictedBindingDomains.
// Sets related.R.Activity appropriately.
func (o *Activity) AddPredictedBindingDomains(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PredictedBindingDomain) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.ActivityID, o.ActivityID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"predicted_binding_domains\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 0, []string{"activity_id"}),
				strmangle.WhereClause("\"", "\"", 0, predictedBindingDomainPrimaryKeyColumns),
			)
			values := []interface{}{o.ActivityID, rel.PredbindID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.ActivityID, o.ActivityID)
		}
	}

	if o.R == nil {
		o.R = &activityR{
			PredictedBindingDomains: related,
		}
	} else {
		o.R.PredictedBindingDomains = append(o.R.PredictedBindingDomains, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &predictedBindingDomainR{
				Activity: o,
			}
		} else {
			rel.R.Activity = o
		}
	}
	return nil
}

// SetPredictedBindingDomains removes all previously related items of the
// activity replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Activity's PredictedBindingDomains accordingly.
// Replaces o.R.PredictedBindingDomains with related.
// Sets related.R.Activity's PredictedBindingDomains accordingly.
func (o *Activity) SetPredictedBindingDomains(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PredictedBindingDomain) error {
	query := "update \"predicted_binding_domains\" set \"activity_id\" = null where \"activity_id\" = ?"
	values := []interface{}{o.ActivityID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.PredictedBindingDomains {
			queries.SetScanner(&rel.ActivityID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Activity = nil
		}
		o.R.PredictedBindingDomains = nil
	}

	return o.AddPredictedBindingDomains(ctx, exec, insert, related...)
}

// RemovePredictedBindingDomains relationships from objects passed in.
// Removes related items from R.PredictedBindingDomains (uses pointer comparison, removal does not keep order)
// Sets related.R.Activity.
func (o *Activity) RemovePredictedBindingDomains(ctx context.Context, exec boil.ContextExecutor, related ...*PredictedBindingDomain) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.ActivityID, nil)
		if rel.R != nil {
			rel.R.Activity = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("activity_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.PredictedBindingDomains {
			if rel != ri {
				continue
			}

			ln := len(o.R.PredictedBindingDomains)
			if ln > 1 && i < ln-1 {
				o.R.PredictedBindingDomains[i] = o.R.PredictedBindingDomains[ln-1]
			}
			o.R.PredictedBindingDomains = o.R.PredictedBindingDomains[:ln-1]
			break
		}
	}

	return nil
}

// Activities retrieves all the records using an executor.
func Activities(mods ...qm.QueryMod) activityQuery {
	mods = append(mods, qm.From("\"activities\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"activities\".*"})
	}

	return activityQuery{q}
}

// FindActivity retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindActivity(ctx context.Context, exec boil.ContextExecutor, activityID int64, selectCols ...string) (*Activity, error) {
	activityObj := &Activity{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"activities\" where \"activity_id\"=?", sel,
	)

	q := queries.Raw(query, activityID)

	err := q.Bind(ctx, exec, activityObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from activities")
	}

	if err = activityObj.doAfterSelectHooks(ctx, exec); err != nil {
		return activityObj, err
	}

	return activityObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Activity) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no activities provided for insertion")
	}

	var err error

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(activityColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	activityInsertCacheMut.RLock()
	cache, cached := activityInsertCache[key]
	activityInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			activityAllColumns,
			activityColumnsWithDefault,
			activityColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(activityType, activityMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(activityType, activityMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"activities\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"activities\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into activities")
	}

	if !cached {
		activityInsertCacheMut.Lock()
		activityInsertCache[key] = cache
		activityInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the Activity.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Activity) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	activityUpdateCacheMut.RLock()
	cache, cached := activityUpdateCache[key]
	activityUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			activityAllColumns,
			activityPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update activities, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"activities\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 0, wl),
			strmangle.WhereClause("\"", "\"", 0, activityPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(activityType, activityMapping, append(wl, activityPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update activities row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for activities")
	}

	if !cached {
		activityUpdateCacheMut.Lock()
		activityUpdateCache[key] = cache
		activityUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q activityQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for activities")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for activities")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o ActivitySlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), activityPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"activities\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 0, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, activityPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in activity slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all activity")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Activity) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no activities provided for upsert")
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(activityColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	activityUpsertCacheMut.RLock()
	cache, cached := activityUpsertCache[key]
	activityUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			activityAllColumns,
			activityColumnsWithDefault,
			activityColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			activityAllColumns,
			activityPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert activities, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(activityPrimaryKeyColumns))
			copy(conflict, activityPrimaryKeyColumns)
		}
		cache.query = buildUpsertQuerySQLite(dialect, "\"activities\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(activityType, activityMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(activityType, activityMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert activities")
	}

	if !cached {
		activityUpsertCacheMut.Lock()
		activityUpsertCache[key] = cache
		activityUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single Activity record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Activity) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Activity provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), activityPrimaryKeyMapping)
	sql := "DELETE FROM \"activities\" WHERE \"activity_id\"=?"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from activities")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for activities")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q activityQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no activityQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from activities")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for activities")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o ActivitySlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(activityBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), activityPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"activities\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, activityPrimaryKeyColumns, len(o))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from activity slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for activities")
	}

	if len(activityAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Activity) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindActivity(ctx, exec, o.ActivityID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *ActivitySlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := ActivitySlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), activityPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"activities\".* FROM \"activities\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 0, activityPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in ActivitySlice")
	}

	*o = slice

	return nil
}

// ActivityExists checks if the Activity row exists.
func ActivityExists(ctx context.Context, exec boil.ContextExecutor, activityID int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"activities\" where \"activity_id\"=? limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, activityID)
	}
	row := exec.QueryRowContext(ctx, sql, activityID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if activities exists")
	}

	return exists, nil
}
